<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>$.on用法</title>
    <url>/2020/06/19/$.on%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>RenderPage和RenderBody</title>
    <url>/2020/06/19/RenderPage%E5%92%8CRenderBody/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>ASP.NET Core</title>
    <url>/2020/06/19/ASP.NET%20Core/</url>
    <content><![CDATA[<h1 id="ASP-NET-Core-文档"><a href="#ASP-NET-Core-文档" class="headerlink" title="ASP.NET Core 文档"></a>ASP.NET Core 文档</h1><h2 id="ASP-NET-Core-简介"><a href="#ASP-NET-Core-简介" class="headerlink" title="ASP.NET Core 简介"></a>ASP.NET Core 简介</h2><h2 id="在ASP-NET-4-x-和ASP-NET-Core-之间进行选择"><a href="#在ASP-NET-4-x-和ASP-NET-Core-之间进行选择" class="headerlink" title="在ASP.NET 4.x 和ASP.NET Core 之间进行选择"></a>在ASP.NET 4.x 和ASP.NET Core 之间进行选择</h2><h3 id="Core"><a href="#Core" class="headerlink" title="Core"></a>Core</h3><blockquote>
<p>ASP.NET Core 是一个跨平台的开源框架，用于在 Windows、macOS 或 Linux 上生成基于云的新式 Web 应用。</p>
</blockquote>
<h3 id="Net-4-x"><a href="#Net-4-x" class="headerlink" title=".Net 4.x"></a>.Net 4.x</h3><blockquote>
<p>ASP.NET 4.x 是一个成熟的框架，提供在 Windows 上生成基于服务器的企业级 Web 应用所需的服务。</p>
</blockquote>
<h3 id="框架选择"><a href="#框架选择" class="headerlink" title="框架选择"></a>框架选择</h3><table>
<thead>
<tr>
<th>ASP.NET Core</th>
<th>ASP.NET 4.x</th>
</tr>
</thead>
<tbody><tr>
<td>针对 Windows、macOS 或 Linux 进行生成</td>
<td>针对 Windows 进行生成</td>
</tr>
<tr>
<td>Razor 页面 是在 ASP.NET Core 2.x 及更高版本中创建 Web UI 时建议使用的方法。 另请参阅 MVCWeb API 和 SignalR。</td>
<td>使用 Web 窗体、SignalR、MVC、Web API、WebHooks 或网页</td>
</tr>
<tr>
<td>每个计算机多个版本</td>
<td>每个计算机一个版本</td>
</tr>
<tr>
<td>使用 C# 或 F# 通过 Visual Studio、Visual Studio for Mac 或 Visual Studio Code 进行开发</td>
<td>使用 C#、VB 或 F# 通过 Visual Studio 进行开发</td>
</tr>
<tr>
<td>比 ASP.NET 4.x 性能更高</td>
<td>良好的性能</td>
</tr>
<tr>
<td>使用 .NET Core 运行时</td>
<td>使用 .NET Framework 运行时</td>
</tr>
</tbody></table>
<h3 id="为服务器应用选择-NET-Core-或-NET-Framework"><a href="#为服务器应用选择-NET-Core-或-NET-Framework" class="headerlink" title="为服务器应用选择 .NET Core 或 .NET Framework"></a>为服务器应用选择 .NET Core 或 .NET Framework</h3><p>1.微软推荐Core 跨平台面向微服务</p>
]]></content>
  </entry>
  <entry>
    <title>Emmet语法</title>
    <url>/2020/06/19/Emmet%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="Emmet语法-用来快速创建html元素"><a href="#Emmet语法-用来快速创建html元素" class="headerlink" title="Emmet语法:用来快速创建html元素"></a>Emmet语法:用来快速创建html元素</h1><p>1.div&gt;span (div内嵌套span)</p>
<p>2.div+span (div兄弟span)</p>
<p>3.div&gt;p*5 (div内嵌套5个p标签)</p>
<p>4.div&gt;p+span^h1+strong</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">strong</span>&gt;</span><span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>5.div&gt;(p&gt;span)+h2来代替^</p>
<p>6.div#main&gt;div.box+p.p1+span.title^div#footer&gt;div.box2</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"main"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"p1"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"title"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"footer"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box2"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>6.生成内容用{}</p>
<p>7.#main</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"main"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>8.w20+h30+m20-30-40-50+fz20+lh50px+bgc#333+dib(没成功,但可以单个写)</p>
]]></content>
  </entry>
  <entry>
    <title>Cross-Domain</title>
    <url>/2020/06/19/Cross-Domain/</url>
    <content><![CDATA[<h1 id="跨域的几种方式"><a href="#跨域的几种方式" class="headerlink" title="跨域的几种方式"></a>跨域的几种方式</h1><h2 id="一、什么是跨域"><a href="#一、什么是跨域" class="headerlink" title="一、什么是跨域"></a>一、什么是跨域</h2><blockquote>
<p>JavaScript出于安全方面的考虑，不允许跨域调用其他页面的对象。那什么是跨域呢，简单地理解就是因为JavaScript同源策略的限制，a.com域名下的js无法操作b.com或是c.a.com域名下的对象。</p>
</blockquote>
<p><strong>有一点必须要注意：跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了。之所以会跨域，是因为受到了同源策略的限制，同源策略要求源相同才能正常进行通信，即协议、域名、端口号都完全一致。</strong></p>
<h3 id="特别说明两点"><a href="#特别说明两点" class="headerlink" title="特别说明两点"></a>特别说明两点</h3><ol>
<li><p>如果是协议和端口造成的跨域问题“前台”是无能为力的。</p>
</li>
<li><p>在跨域问题上，域仅仅是通过“URL的首部”来识别而不会根据域名对应的IP地址是否相同来判断。“URL的首部”可以理解为“协议, 域名和端口必须匹配”。</p>
</li>
</ol>
<a id="more"></a>
<h2 id="二、什么是同源策略及其限制"><a href="#二、什么是同源策略及其限制" class="headerlink" title="二、什么是同源策略及其限制"></a>二、什么是同源策略及其限制</h2><blockquote>
<p>同源策略限制从一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的关键的安全机制。它的存在可以保护用户隐私信息，防止身份伪造等(读取Cookie)。</p>
</blockquote>
<p>同源策略限制内容有：</p>
<ul>
<li><p>Cookie、LocalStorage、IndexedDB 等存储性内容</p>
</li>
<li><p>DOM 节点</p>
</li>
<li><p>AJAX 请求不能发送</p>
</li>
</ul>
<p><strong>但是有三个标签是允许跨域加载资源：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>&lt;img src=XXX&gt;</span><br><span class="line"><span class="number">2.</span>&lt;link href=XXX&gt;</span><br><span class="line"><span class="number">3.</span>&lt;script src=XXX&gt;</span><br></pre></td></tr></table></figure>

<h2 id="三、处理跨域方法——JSONP"><a href="#三、处理跨域方法——JSONP" class="headerlink" title="三、处理跨域方法——JSONP"></a>三、处理跨域方法——JSONP</h2><ol>
<li><p>JSONP原理 <br>利用 &lt;script&gt; 元素的这个开放策略，网页可以得到从其他来源动态产生的 JSON 数据。JSONP请求一定需要对方的服务器做支持才可以。</p>
</li>
<li><p>JSONP和AJAX对比<br>JSONP和AJAX相同，都是客户端向服务器端发送请求，从服务器端获取数据的方式。但AJAX属于同源策略，JSONP属于非同源策略（跨域请求）</p>
</li>
<li><p>JSONP优缺点<br>JSONP优点是兼容性好，可用于解决主流浏览器的跨域数据访问的问题。缺点是仅支持get方法具有局限性。</p>
</li>
</ol>
<p>4.JSONP的流程(以第三方API地址为例，不必考虑后台程序)</p>
<ul>
<li><p>声明一个回调函数，其函数名(如fn)当做参数值，要传递给跨域请求数据的服务器，函数形参为要获取目标数据(服务器返回的data)。</p>
</li>
<li><p>创建一个&lt;script&gt;标签，把那个跨域的API数据接口地址，赋值给script的src,还要在这个地址中向服务器传递该函数名（可以通过问号传参:?callback=fn）。</p>
</li>
<li><p>服务器接收到请求后，需要进行特殊的处理：把传递进来的函数名和它需要给你的数据拼接成一个字符串,例如：传递进去的函数名是fn，它准备好的数据是fn([{“name”:”jianshu”}]）。</p>
</li>
<li><p>最后服务器把准备的数据通过HTTP协议返回给客户端，客户端再调用执行之前声明的回调函数（fn），对返回的数据进行操作。</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;               <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">        alert(data.msg);</span><br><span class="line">    &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;script type="text/</span>javascript<span class="string">" src="</span>http:<span class="comment">//crossdomain.com/jsonServerResponse?jsonp=fn"&gt;</span></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<p><br>5. jQuery的jsonp形式\</p>
<p>JSONP都是GET和异步请求的，不存在其他的请求方式和同步请求，且jQuery默认就会给JSONP的请求清除缓存。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    url:<span class="string">"http://crossdomain.com/jsonServerResponse"</span>,</span><br><span class="line">    qdataType:<span class="string">"jsonp"</span>,</span><br><span class="line">    type:<span class="string">"get"</span>,<span class="comment">//可以省略 jsonpCallback:"fn",//-&gt;自定义传递给服务器的函数名，而不是使用jQuery自动生成的，可省略 jsonp:"jsonp",//-&gt;把传递函数名的那个形参callback变为jsonp，可省略</span></span><br><span class="line">    success:<span class="function"><span class="keyword">function</span> (<span class="params">data</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="四、处理跨域方法——CORS"><a href="#四、处理跨域方法——CORS" class="headerlink" title="四、处理跨域方法——CORS"></a>四、处理跨域方法——CORS</h2><ol>
<li><p>CORS原理:<br>整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。</p>
</li>
<li><p>CORS优缺点</p>
</li>
</ol>
<p>CORS要求浏览器(&gt;IE10)和服务器的同时支持，是跨域的根本解决方法，由浏览器自动完成。<br>优点在于功能更加强大支持各种HTTP Method，缺点是兼容性不如JSONP。<br>只需要在服务器端做一些小小的改造即可：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">header(<span class="string">"Access-Control-Allow-Origin:*"</span>）; header(<span class="string">"Access-Control-Allow-Methods:POST,GET"</span>）;</span><br></pre></td></tr></table></figure>

<p>例如：网站<a href="http://localhost:63342/" target="_blank" rel="noopener">http://localhost:63342/</a> 页面要请求<a href="http://localhost:3000/users/userlist" target="_blank" rel="noopener">http://localhost:3000/users/userlist</a>  页面，userlist页面返回json字符串格{name: ‘Mr.Cao’, gender: ‘male’, career: ‘IT Education’}</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在服务器端设置同源策略地址</span></span><br><span class="line">router.get(<span class="string">"/userlist"</span>,</span><br><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> user = &#123;<span class="attr">name</span>: <span class="string">'Mr.Cao'</span>, <span class="attr">gender</span>: <span class="string">'male'</span>, <span class="attr">career</span>: <span class="string">'IT Education'</span>&#125;;      </span><br><span class="line">    res.writeHeader(<span class="number">200</span>,&#123;<span class="string">"Access-Control-Allow-Origin"</span>:<span class="string">'http://localhost:63342'</span>&#125;);</span><br><span class="line">    res.write(<span class="built_in">JSON</span>.stringify(user));      res.end();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在响应头上添加Access-Control-Allow-Origin属性，指定同源策略的地址。同源策略默认地址是网页的本身。只要浏览器检测到响应头带上了CORS，并且允许的源包括了本网站，那么就不会拦截请求响应。</p>
<h2 id="五、处理跨域方法——WebSocket"><a href="#五、处理跨域方法——WebSocket" class="headerlink" title="五、处理跨域方法——WebSocket"></a>五、处理跨域方法——WebSocket</h2><p>Websocket是HTML5的一个持久化的协议，它实现了浏览器与服务器的全双工通信，同时也是跨域的一种解决方案。WebSocket和HTTP都是应用层协议，都基于 TCP 协议。但是 WebSocket 是一种双向通信协议，在建立连接之后，WebSocket 的 server 与 client 都能主动向对方发送或接收数据。同时，WebSocket 在建立连接时需要借助 HTTP 协议，连接建立好了之后 client 与 server 之间的双向通信就与 HTTP 无关了。</p>
<p>原生WebSocket API使用起来不太方便，我们使用Socket.io，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//前端代码：</span></span><br><span class="line">&lt;div&gt;user input：&lt;input type=<span class="string">"text"</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;script src="./</span>socket.io.js<span class="string">"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;script&gt; var socket = io('http://www.domain2.com:8080');</span></span><br><span class="line"><span class="string">// 连接成功处理</span></span><br><span class="line"><span class="string">socket.on('connect', function() &#123;</span></span><br><span class="line"><span class="string">//监听服务端消息</span></span><br><span class="line"><span class="string">socket.on('message', function(msg) &#123;         console.log('data from server: ---&gt; ' + msg);      &#125;);  </span></span><br><span class="line"><span class="string">// 监听服务端关闭</span></span><br><span class="line"><span class="string">socket.on('disconnect', function() &#123;          console.log('Server socket has closed.');      &#125;); &#125;);</span></span><br><span class="line"><span class="string">document.getElementsByTagName('input')[0].onblur = function() &#123;</span></span><br><span class="line"><span class="string">    socket.send(this.value);</span></span><br><span class="line"><span class="string">&#125;; &lt;/script&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Nodejs socket后台：</span></span><br><span class="line"><span class="keyword">var</span> http = require(<span class="string">'http'</span>); <span class="keyword">var</span> socket = require(<span class="string">'socket.io'</span>);</span><br><span class="line"><span class="comment">// 启http服务</span></span><br><span class="line"><span class="keyword">var</span> server = http.createServer(function(req, res) &#123;     res.writeHead(<span class="number">200</span>, &#123;<span class="string">'Content-type'</span>: <span class="string">'text/html'</span>     &#125;);</span><br><span class="line">res.end(); &#125;);</span><br><span class="line">server.listen(<span class="string">'8080'</span>);</span><br><span class="line">console.log(<span class="string">'Server is running at port 8080...'</span>);</span><br><span class="line"><span class="comment">// 监听socket连接</span></span><br><span class="line">socket.listen(server).on(<span class="string">'connection'</span>, function(client) &#123;</span><br><span class="line">    <span class="comment">// 接收信息</span></span><br><span class="line">    client.on(<span class="string">'message'</span>, function(msg) &#123;         client.send(<span class="string">'hello：'</span> + msg);         console.log(<span class="string">'data from client: ---&gt; '</span> + msg);     &#125;);</span><br><span class="line">    <span class="comment">// 断开处理</span></span><br><span class="line">    client.on(<span class="string">'disconnect'</span>, function() &#123;                console.log(<span class="string">'Client socket has closed.'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="六、处理跨域方法——postMessage"><a href="#六、处理跨域方法——postMessage" class="headerlink" title="六、处理跨域方法——postMessage"></a>六、处理跨域方法——postMessage</h2><blockquote>
<p>如果两个网页不同源，就无法拿到对方的DOM。典型的例子是iframe窗口和window.open方法打开的窗口，它们与父窗口无法通信。HTML5为了解决这个问题，引入了一个全新的API：跨文档通信 API（Cross-document messaging）。这个API为window对象新增了一个window.postMessage方法，允许跨窗口通信，不论这两个窗口是否同源。postMessage方法的第一个参数是具体的信息内容，第二个参数是接收消息的窗口的源（origin），即”协议 + 域名 + 端口”。也可以设为*，表示不限制域名，向所有窗口发送。</p>
</blockquote>
<p>接下来我们看个例子：<br><a href="http://localhost:63342/index.html页面向http://localhost:63342/index.html传递“跨域请求信息”" target="_blank" rel="noopener">http://localhost:63342/index.html页面向http://localhost:63342/index.html传递“跨域请求信息”</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//发送信息页面 http://localhost:63342/index.html</span></span><br><span class="line"></span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">    &lt;title&gt;跨域请求&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">    &lt;iframe src=<span class="string">"http://localhost:3000/users/reg"</span> id=<span class="string">"frm"</span>&gt;&lt;<span class="regexp">/iframe&gt;</span></span><br><span class="line"><span class="regexp">    &lt;input type="button" value="OK" onclick="run()"&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>body&gt;</span><br><span class="line">&lt;<span class="regexp">/html&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">function  run()&#123;</span></span><br><span class="line"><span class="regexp">    var frm=document.getElementById("frm");           frm.contentWindow.postMessage("跨域请求信息","http:/</span><span class="regexp">/localhost:3000");</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//接收信息页面 http://localhost:3000/message.html  </span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">"message"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;  </span><br><span class="line">    <span class="comment">//通过监听message事件，可以监听对方发送的消息。</span></span><br><span class="line">    <span class="built_in">console</span>.log(e.data);</span><br><span class="line">&#125;,<span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>Hexo</title>
    <url>/2020/06/19/Hexo/</url>
    <content><![CDATA[<h1 id="Hexo总结"><a href="#Hexo总结" class="headerlink" title="Hexo总结"></a>Hexo总结</h1><h2 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h2><ol>
<li><p>config.yml<br> 网站的 配置 信息，您可以在此配置大部分的参数。</p>
</li>
<li><p>package.json<br> 应用程序的信息。EJS, Stylus 和 Markdown renderer 已默认安装，您可以自由移除。</p>
</li>
<li><p>scaffolds<br> 模版 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。<br> Hexo的模板是指在新建的文章文件中默认填充的内容。例如，如果您修改scaffold/post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。</p>
</li>
<li><p>source<br> 资源文件夹是存放用户资源的地方。除<br> _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。</p>
</li>
<li><p>themes<br> 主题 文件夹。Hexo 会根据主题来生成静态页面。</p>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>MVC和JQGG项目属性对比</title>
    <url>/2020/06/19/MVC%E5%92%8CJQGG%E9%A1%B9%E7%9B%AE%E5%B1%9E%E6%80%A7%E5%AF%B9%E6%AF%94/</url>
    <content><![CDATA[<h1 id="MVC项目属性对比"><a href="#MVC项目属性对比" class="headerlink" title="MVC项目属性对比"></a>MVC项目属性对比</h1><h2 id="应用程序"><a href="#应用程序" class="headerlink" title="应用程序"></a>应用程序</h2>]]></content>
  </entry>
  <entry>
    <title>IIFE(立即执行函数)</title>
    <url>/2020/06/19/IIFE(%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0)/</url>
    <content><![CDATA[<p>###立即执行函数</p>
<p>1.js不允许在一个函数的声明后面加()执行<br>  function test(){</p>
<p>  }()<br>2.所以要加东西把函数变成表达式!,()等</p>
<p>3.IIFE执行完后,立即销毁,所以不需要名字</p>
]]></content>
  </entry>
  <entry>
    <title>JS-Foreach</title>
    <url>/2020/06/19/JS-Foreach/</url>
    <content><![CDATA[<h1 id="JS-Foreach"><a href="#JS-Foreach" class="headerlink" title="JS-Foreach"></a>JS-Foreach</h1><h2 id="普通的for循环"><a href="#普通的for循环" class="headerlink" title="普通的for循环"></a>普通的for循环</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123; <span class="comment">// 这里的i是代表数组的下标</span></span><br><span class="line">    <span class="built_in">console</span>.log(i); <span class="comment">// 0, 1, 2</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="优化版的for循环"><a href="#优化版的for循环" class="headerlink" title="优化版的for循环"></a>优化版的for循环</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, len = arr.length; i &lt; len; i++) &#123; <span class="comment">// 这里的i是代表数组的下标</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(i); <span class="comment">// 0, 1, 2 &#125;;</span></span><br></pre></td></tr></table></figure>

<h2 id="for···of···遍历（支持es6）"><a href="#for···of···遍历（支持es6）" class="headerlink" title="for···of···遍历（支持es6）"></a>for···of···遍历（支持es6）</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> item <span class="keyword">of</span> arr) &#123; <span class="comment">// item代表数组里面的元素</span></span><br><span class="line">    <span class="built_in">console</span>.log(item); <span class="comment">// 1, 2, 3</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr.forEach(<span class="function">(<span class="params">item, index, arr</span>) =&gt;</span> &#123; <span class="comment">// item为arr的元素，index为下标，arr原数组</span></span><br><span class="line">    <span class="built_in">console</span>.log(item); <span class="comment">// 1, 2, 3</span></span><br><span class="line">    <span class="built_in">console</span>.log(index); <span class="comment">// 0, 1, 2</span></span><br><span class="line">    <span class="built_in">console</span>.log(arr); <span class="comment">// [1, 2, 3]</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>缺点：不支持终止循环</strong></p>
<h2 id="some"><a href="#some" class="headerlink" title="some()"></a>some()</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr.some(<span class="function">(<span class="params">item, index, arr</span>) =&gt;</span> &#123; <span class="comment">// item为数组中的元素，index为下标，arr为目标数组</span></span><br><span class="line">    <span class="built_in">console</span>.log(item); <span class="comment">// 1, 2, 3</span></span><br><span class="line">    <span class="built_in">console</span>.log(index); <span class="comment">// 0, 1, 2</span></span><br><span class="line">    <span class="built_in">console</span>.log(arr); <span class="comment">// [1, 2, 3]  </span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>如果有一个元素满足条件，则表达式返回true , 剩余的元素不会再执行检测。</li>
<li>如果没有满足条件的元素，则返回false。</li>
</ul>
<h2 id="every"><a href="#every" class="headerlink" title="every()"></a>every()</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr.every(<span class="function">(<span class="params">item, index, arr</span>) =&gt;</span> &#123; <span class="comment">// item为数组中的元素，index为下标，arr为目标数组</span></span><br><span class="line">    <span class="keyword">return</span> item &gt; <span class="number">0</span>; <span class="comment">// true</span></span><br><span class="line">    <span class="keyword">return</span> index == <span class="number">0</span>; <span class="comment">// false</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>如果数组中检测到有一个元素不满足，则整个表达式返回 false ，且剩余的元素不会再进行检测。</li>
<li>如果所有元素都满足条件，则返回 true。</li>
</ul>
<h2 id="for···in···遍历"><a href="#for···in···遍历" class="headerlink" title="for···in···遍历"></a>for···in···遍历</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var arr &#x3D; [1, 2, 3]</span><br><span class="line">for(var item in arr) &#123; &#x2F;&#x2F; item遍历数组时为数组的下标，遍历对象时为对象的key值</span><br><span class="line">    console.log(item); &#x2F;&#x2F; 0, 1, 2</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>for…in更多是用来遍历对象，很少用来遍历数组， 不过 item 对应与数组的 key值，建议不要用该方法来遍历数组，因为它的效率是最低的。</strong></p>
<h2 id="filter（）"><a href="#filter（）" class="headerlink" title="filter（）"></a>filter（）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var arr &#x3D; [1, 2, 3];</span><br><span class="line">arr.filter(item &#x3D;&gt; &#123; &#x2F;&#x2F; item为数组当前的元素</span><br><span class="line">    return item &gt; 1; &#x2F;&#x2F; [2, 3]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr.map(<span class="function"><span class="params">item</span> =&gt;</span> &#123; <span class="comment">// item为数组的元素</span></span><br><span class="line">    <span class="built_in">console</span>.log(item); <span class="comment">// 1, 2, 3</span></span><br><span class="line">    <span class="keyword">return</span> item * <span class="number">2</span>; <span class="comment">// 返回一个处理过的新数组[2, 4, 6]</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="map和filter的区别"><a href="#map和filter的区别" class="headerlink" title="map和filter的区别"></a>map和filter的区别</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr=[<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> res1=arr.map(<span class="function"><span class="keyword">function</span> (<span class="params">item,index,array</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// return array[index]; //用这种方法也可以获取到当前处理的元素</span></span><br><span class="line">  <span class="keyword">return</span> item&gt;<span class="number">1</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> res2=arr.filter(<span class="function"><span class="keyword">function</span> (<span class="params">item,index,array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> item&gt;<span class="number">1</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(res1,res2);<span class="comment">//[ true, true, false, true, true, false ] [ 2, 4, 5, 3 ]</span></span><br></pre></td></tr></table></figure>

<p><strong>区别：<br>可以看到，map的结果只是对当前元素调用函数后（x是否大于1）的结果。而filter 会将结果为true的数组存到新的数组里面.</strong></p>
<br/>

<h2 id="javaScript：关于-1-2-3-map-parseInt-问题的解析"><a href="#javaScript：关于-1-2-3-map-parseInt-问题的解析" class="headerlink" title="javaScript：关于 [1,2,3]map(parseInt)问题的解析"></a>javaScript：关于 [1,2,3]map(parseInt)问题的解析</h2><ol>
<li>map()方法的定义用法和参数：  </li>
</ol>
<ul>
<li><p>map()方法定义：<br>  按照原始数组元素顺序依次处理元素，然后返回一个新数组</p>
</li>
<li><p>map()语法：<br>  array.map(function(item,index,array),this)</p>
</li>
<li><p>参数说明：<br>  1.item： 必须，当前处理的数组的值<br>  2.index：可选，当前处理的值得索引<br>  3.array：可选，当前处理的值所属于的数组对象<br>  4.this：可选。对象作为该执行回调时使用，传递给函数，用作 “this” 的值。如果省略了 thisValue ，”this” 的值为 “undefined”。</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line">numbers.map(<span class="function"><span class="keyword">function</span>(<span class="params">item,index</span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(item+”-”+index);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>parseInt()函数的定义用法和参数:</li>
</ol>
<ul>
<li><p>parseInt()方法定义：<br>  解析一个字符串，并返回一个整数。当参数 radix 的值为 0，或没有设置该参数时，parseInt() 会根据 string 来判断数字的基数。</p>
<ul>
<li>如果 string 以 “0x” 开头，parseInt() 会把 string 的其余部分解析为十六进制的整数。</li>
<li>如果 string 以 0 开头，那么 ECMAScript v3 允许 parseInt() 的一个实现把其后的字符解析为八进制或十六进制的数字。</li>
<li>如果 string 以 1 ~ 9 的数字开头，parseInt() 将把它解析为十进制的整数。</li>
</ul>
</li>
<li><p>parseInt(string,radix)<br>  string: 必须，要被解析的字符串<br>  radix：可选。表示要解析的数字基数，介于2-36之间。</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="number">1</span>,<span class="number">0</span>));<span class="comment">//将十进制数1转化为十进制数，仍为1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="number">2</span>,<span class="number">1</span>));<span class="comment">//将一进制数2（不存在）转化为十进制数，NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="number">3</span>,<span class="number">2</span>));<span class="comment">//NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="number">4</span>,<span class="number">3</span>));<span class="comment">//NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="number">10</span>,<span class="number">4</span>));<span class="comment">//将四进制数10转化为十进制数为4</span></span><br></pre></td></tr></table></figure>

<br/>

<h2 id="附（-NET-MVC-ActionResult详解）"><a href="#附（-NET-MVC-ActionResult详解）" class="headerlink" title="附（.NET MVC ActionResult详解）"></a>附（.NET MVC ActionResult详解）</h2><blockquote>
<p>ActionResult是控制器方法执行后返回的结果类型，控制器方法可以返回一个直接或间接从ActionResult抽象类继承的类型，如果返回的是非ActionResult类型，控制器将会将结果转换为一个ContentResult类型。默认的ControllerActionInvoker调用ActionResult.ExecuteResult方法生成应答结果。</p>
</blockquote>
<h3 id="各种Result说明"><a href="#各种Result说明" class="headerlink" title="各种Result说明"></a>各种Result说明</h3><table>
<thead>
<tr>
<th>动作类型</th>
<th>行为</th>
</tr>
</thead>
<tbody><tr>
<td>ContentResult</td>
<td>返回简单的纯文本内容，可通过ContentType属性指定应答文档类型，通过ContentEncoding属性指定应答文档的字符编码。可通过Controller类中的Content方法便捷地返回ContentResult对象。如果控制器方法返回非ActionResult对象，MVC将简单地以返回对象的ToString()内容为基础产生一个ContentResult对象。</td>
</tr>
<tr>
<td>FileContentResult</td>
<td>返回文件内容。FilePath通过路径传送文件到客户端，FileContent通过二进制数据的方式，而FileStream是通过Stream的方式来传送。Controller为这三个文件结果类型提供了一个名为File的重载方法。</td>
</tr>
<tr>
<td>FilePathResult</td>
<td>返回路径文件的内容</td>
</tr>
<tr>
<td>EmptyResult</td>
<td>返回一个空的结果。如果控制器方法返回一个null，MVC将其转换成EmptyResult对象。</td>
</tr>
<tr>
<td>JavaScriptResult</td>
<td>返回一段JavaScript代码.本质上是一个文本内容，只是将Response.ContentType设置为 application/x-javascript，此结果应该和MicrosoftMvcAjax.js脚本配合使用，客户端接收到Ajax应答后，将判断Response.ContentType的值，如果是application/x-javascript,则直接eval执行返回的应答内容。此结果类型对应的Controller方法为JavaScript。</td>
</tr>
<tr>
<td><strong>JsonResult</strong></td>
<td><strong>返回Json格式数据。 MVC将Response.ContentType设置为application/json，并通过JavaScriptSerializer类将指定对象序列化为Json表示方式。需要注意，默认情况下，MVC不允许GET请求返回JSON结果，要解除此限制，在生成JsonResult对象时，将其JsonRequestBehavior属性设置为JsonRequestBehavior.AllowGet。此结果对应的Controller方法为Json。</strong></td>
</tr>
<tr>
<td>RedirectToResult</td>
<td>表示一个连接跳转，相当于ASP.NET中的Response.Redirect方法。对应的Controller方法为Redirect。</td>
</tr>
<tr>
<td>HttpUnauthorizedResult</td>
<td>返回HTTP403未授权状态码</td>
</tr>
<tr>
<td>RedirectToRouteResult</td>
<td>重定向到不同的控制器动作</td>
</tr>
<tr>
<td><strong>ViewResult</strong></td>
<td><strong>接收视图引擎的响应</strong></td>
</tr>
<tr>
<td><strong>PartialViewResult</strong></td>
<td><strong>接收分部视图引擎的响应</strong></td>
</tr>
</tbody></table>
<h3 id="Result的封装"><a href="#Result的封装" class="headerlink" title="Result的封装"></a>Result的封装</h3><table>
<thead>
<tr>
<th>类型</th>
<th>实例化对象</th>
<th>封装方法</th>
</tr>
</thead>
<tbody><tr>
<td>Json结果</td>
<td>JsonResult</td>
<td>Json（Object）</td>
</tr>
<tr>
<td>跳转</td>
<td>RedirectResult</td>
<td>Redirect（url）</td>
</tr>
<tr>
<td>文件</td>
<td>FileResult</td>
<td>File（）</td>
</tr>
<tr>
<td>视图</td>
<td>ViewResult</td>
<td>View（）</td>
</tr>
<tr>
<td>文本</td>
<td>ContentResult</td>
<td>Content（“”）;</td>
</tr>
</tbody></table>
]]></content>
  </entry>
  <entry>
    <title>Js函数写法</title>
    <url>/2020/06/19/Js%E5%87%BD%E6%95%B0%E5%86%99%E6%B3%95/</url>
    <content><![CDATA[<h1 id="js函数写法"><a href="#js函数写法" class="headerlink" title="js函数写法"></a>js函数写法</h1><h2 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fn(<span class="number">111</span>);</span><br><span class="line"></span><br><span class="line">funciton fn(param)&#123;</span><br><span class="line">    alert(param);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//js编译器会优先编译声明式函数，然后再逐上而下执行js</span></span><br></pre></td></tr></table></figure>

<h2 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fn(<span class="number">111</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span> <span class="title">fun</span> (<span class="params">param</span>)</span>&#123;</span><br><span class="line">    alert(param);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//会报错，因为没有声明fn函数，如果放在下面则可以</span></span><br></pre></td></tr></table></figure>

<h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="number">111</span>);</span><br><span class="line">&#125;();</span><br><span class="line"><span class="comment">//因为没有把函数赋给变量，所以被编辑器当做声明式表达式，声明式要有方法名</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">kk</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="number">111</span>);</span><br><span class="line">&#125;()</span><br><span class="line"><span class="comment">//声明式函数无法直接执行，要加扩号，把他变成对象</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><blockquote>
<p>当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">'iceman'</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fn2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> fn3 = fn1();</span><br><span class="line"></span><br><span class="line">fn3();</span><br></pre></td></tr></table></figure>

<p>这样就清晰地展示了闭包：</p>
<ul>
<li><p>fn2的词法作用域能访问fn1的作用域</p>
</li>
<li><p>将fn2当做一个值返回</p>
</li>
<li><p>fn1执行后，将fn2的引用赋值给fn3</p>
</li>
<li><p>执行fn3，输出了变量name</p>
</li>
</ul>
<h3 id="经典代码"><a href="#经典代码" class="headerlink" title="经典代码"></a>经典代码</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这是因为setTimeout中的匿名函数执行的时候，for循环都已经结束了</span></span><br></pre></td></tr></table></figure>

<p>目标</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span> (<span class="params">j</span>) </span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(j);</span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//我们可以让i在每次迭代的时候，都产生一个私有的作用域，在这个私有的作用域中保存当前i的值。</span></span><br></pre></td></tr></table></figure>

<h2 id="闭包的应用"><a href="#闭包的应用" class="headerlink" title="闭包的应用"></a>闭包的应用</h2><p>闭包的应用比较典型是定义模块，我们将操作函数暴露给外部，而细节隐藏在模块内部：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">module</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arr = [];</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> val == <span class="string">'number'</span>) &#123;</span><br><span class="line">            arr.push(val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params">index</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; arr.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> arr[index]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        add: add,</span><br><span class="line">        <span class="keyword">get</span>: <span class="keyword">get</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var mod1 = module();</span><br><span class="line">mod1.add(1);</span><br><span class="line">mod1.add(2);</span><br><span class="line">mod1.add('xxx');</span><br><span class="line">console.log(mod1.<span class="keyword">get</span>(2));</span><br></pre></td></tr></table></figure>

<h2 id="在for循环中运行setTimeout的三种情况"><a href="#在for循环中运行setTimeout的三种情况" class="headerlink" title="在for循环中运行setTimeout的三种情况"></a>在for循环中运行setTimeout的三种情况</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">    setTimeout(<span class="built_in">console</span>.log(i),<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//直接console.log是个对象，他是个匿名函数得出来的对象（自我理解）</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);  <span class="comment">//连续的10个10</span></span><br><span class="line">    &#125;,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//匿名函数，在settimeout里要等异步执行</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">    setTimeout(<span class="string">"console.log(i)"</span>,<span class="number">1000</span>);<span class="comment">//连续的10个10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//console.log完了以后进行转换字符串工作，所以遵循settimeout的异步操作</span></span><br></pre></td></tr></table></figure>

<p><strong>异步执行的运行机制如下：</strong></p>
<ul>
<li>所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。</li>
<li>主线程之外，还存在一个”任务队列”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。</li>
<li>一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。</li>
<li>主线程不断重复上面的第三步。</li>
<li>主线程从”任务队列”中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）。只要主线程空了，就会去读取”任务队列”，这就是JavaScript的运行机制。这个过程会循环反复。</li>
</ul>
<p><strong>一般来说，有以下四种会放入异步任务队列：</strong></p>
<ul>
<li>setTimeout和setlnterval</li>
<li>DOM事件</li>
<li>ES6中的Promise</li>
<li>Ajax异步请求</li>
</ul>
<h2 id="JavaScript的垃圾回收机制"><a href="#JavaScript的垃圾回收机制" class="headerlink" title="JavaScript的垃圾回收机制"></a>JavaScript的垃圾回收机制</h2><blockquote>
<p>在js中，如果一个对象不再被引用，那么这个对象就会被GC回收。如果两个对象互相引用，而不再被第三者引用，那么这两个互相引用的对象也会被回收。</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>MVC应用程序生命周期</title>
    <url>/2020/06/19/MVC%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<h1 id="ASP-Net-MVC-应用程序的生命周期"><a href="#ASP-Net-MVC-应用程序的生命周期" class="headerlink" title="ASP.Net MVC 应用程序的生命周期"></a>ASP.Net MVC 应用程序的生命周期</h1><h2 id="一-介绍"><a href="#一-介绍" class="headerlink" title="一.介绍"></a>一.介绍</h2><blockquote>
<p>定义 ASP.NET 应用程序中的所有应用程序对象共有的方法、属性和事件。此类是用户在 <strong>Global.asax</strong> 文件中所定义的应用程序的基类。</p>
</blockquote>
<blockquote>
<p>MVC有两个生命周期，一个为应用生命周期，二为请求生命周期。</p>
</blockquote>
<h2 id="二-应用生命周期"><a href="#二-应用生命周期" class="headerlink" title="二.应用生命周期"></a>二.应用生命周期</h2><p><strong>应用程序生命周期是指在申请过程实际开始运行IIS，直到它停止的时间。这是通过在应用程序中的启动文件的应用程序开始和结束标记事件。</strong></p>
<p><img src="../../images/2019.10.31/MVC-Cycle/MVC-Application-Cycle.png" alt="Image text"></p>
<h2 id="三-请求生命周期"><a href="#三-请求生命周期" class="headerlink" title="三.请求生命周期"></a>三.请求生命周期</h2><p>发生每一HTTP请求是由我们的应用处理的时间的事件序列。</p>
<p>入口点为每个MVC应用始终由ASP.NET收到请求后，计算出应该如何通过URL路由模块来处理。</p>
<ol>
<li><p>Routing 路由<br>ASP.NET MVC生命周期中第一个步骤就是路由，路由的过程是根据请求的Url和注册好的路由规则进行匹配，当一旦找到一个与之匹配找路由规则时，ASP.NET MVC路由引擎就把这个请求交给相应的Handler处理。如果没匹配，则返回404错误。<br>注册路由，首先从Global.asax上面注册：</p>
</li>
<li><p>Controller 控制器<br>Controller是MVC最核心的组件，他是连接View与Model的桥梁，在Controller内部会有相应的Action方法，可以决定请求返回的视图或数据。</p>
</li>
<li><p>Action Excution<br>一旦Controller被创建并初始化以后，里面的Action就开始上场了。这里ASP.NET MVC的框架的一个核心组件ActionInvoker就决定了请求到底是哪一个Action的方法。Action方法是真正接收请求的处理方法。<br>Action接收用户的输入，进行相应的逻辑处理并把要返回的数据Model准备好了之后传给相应的视图。</p>
</li>
<li><p>View Engine 视图引擎<br>Action方法的作用是接受输入，然后进行一定的处理并准备响应数据，最后返回一个View Result类型实例。返回的View Result类型这些类型：ViewResult, RedirectToRouteResult, RedirectResult, ContentResult, JsonResult, FileResult, and EmptyResult等等。<br>当我们在Action方法的最后返回一个View Result的时候，ASP.NET MVC框架首先就会选择相应的视图引擎来返回视图。ASP.NET视图引擎都会实现接口IViewEngine。默认ASP.NET MVC框架为我们提供了接口IViewEngine两个实现，视图引擎WebForm和Razor。<br>View视图其实就是一个模板的作用，它是把Action传过来的数据绑定到视图文件中并显示到页面中。</p>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>RedisCommand</title>
    <url>/2020/06/19/RedisCommand/</url>
    <content><![CDATA[<h1 id="RedisCommand记录"><a href="#RedisCommand记录" class="headerlink" title="RedisCommand记录"></a>RedisCommand记录</h1><p>1.mset: 同时为多个键设置值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; MSET date &quot;2012.3.30&quot; time &quot;11:00 a.m.&quot; weather &quot;sunny&quot;</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<p>2.expire: 设置过期时间</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; expire name 5 # 5s 后过期</span><br></pre></td></tr></table></figure>

<p>3.setex: set+expire</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; setex name 5 codehole # 5s 后过期，等价于 set+expire</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>4.setnx: set if not exist</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; setnx name codehole # 如果 name 不存在就执行 set 创建</span><br></pre></td></tr></table></figure>

<p>5.incr和incrby: 对整形进行修改</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; incrby age -5</span><br></pre></td></tr></table></figure>

<p>6.rpush和lpop: 右进左出 队列操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; rpush books python java golang</span><br><span class="line">(integer) 3</span><br><span class="line">&gt; llen books</span><br><span class="line">(integer) 3</span><br><span class="line">&gt; lpop books</span><br><span class="line">&quot;python&quot;</span><br><span class="line">&gt; lpop books</span><br><span class="line">&quot;java&quot;</span><br><span class="line">&gt; lpop books</span><br><span class="line">&quot;golang&quot;</span><br><span class="line">&gt; lpop books</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>

<p>7.rpush和rpop: 右进又出 栈操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; rpush books python java golang</span><br><span class="line">(integer) 3</span><br><span class="line">&gt; rpop books</span><br><span class="line">&quot;golang&quot;</span><br><span class="line">&gt; rpop books</span><br><span class="line">&quot;java&quot;</span><br><span class="line">&gt; rpop books</span><br><span class="line">&quot;python&quot;</span><br><span class="line">&gt; rpop books</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>

<p>8.lindex: 相当于 Java 链表的 get(int index)方法<br>&nbsp; &nbsp;ltrim: 保留方法，在区间内保留</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; rpush books python java golang</span><br><span class="line">(integer) 3</span><br><span class="line">&gt; lindex books 1 # O(n) 慎用</span><br><span class="line">&quot;java&quot;</span><br><span class="line">&gt; lrange books 0 -1 # 获取所有元素，O(n) 慎用</span><br><span class="line">1) &quot;python&quot;</span><br><span class="line">2) &quot;java&quot;</span><br><span class="line">3) &quot;golang&quot;</span><br><span class="line">&gt; ltrim books 1 -1 # O(n) 慎用</span><br><span class="line">OK</span><br><span class="line">&gt; lrange books 0 -1</span><br><span class="line">1) &quot;java&quot;</span><br><span class="line">2) &quot;golang&quot;</span><br><span class="line">&gt; ltrim books 1 0 # 这其实是清空了整个列表，因为区间范围长度为负</span><br><span class="line">OK</span><br><span class="line">&gt; llen books</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>TCP protocol</title>
    <url>/2020/06/19/TCP%20protocol/</url>
    <content><![CDATA[<h1 id="TCP协议详解"><a href="#TCP协议详解" class="headerlink" title="TCP协议详解"></a>TCP协议详解</h1><h2 id="为什么会有TCP-IP协议"><a href="#为什么会有TCP-IP协议" class="headerlink" title="为什么会有TCP/IP协议"></a>为什么会有TCP/IP协议</h2><blockquote>
<p>电脑需要定义一些共通的东西来进行交流，TCP/IP就是为此而生。TCP/IP不是一个协议，而是一个协议族的统称。里面包括了IP协议，IMCP协议，TCP协议，以及我们更加熟悉的http、ftp、pop3协议等等。电脑有了这些，就好像学会了外语一样，就可以和其他的计算机终端做自由的交流了。</p>
</blockquote>
<h2 id="TCP-IP协议分层"><a href="#TCP-IP协议分层" class="headerlink" title="TCP/IP协议分层"></a>TCP/IP协议分层</h2><a id="more"></a>
<h3 id="OSI七层分层"><a href="#OSI七层分层" class="headerlink" title="OSI七层分层"></a>OSI七层分层</h3><p>1.<strong>物理层：比特</strong></p>
<p>主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。它的主要作用是传输比特流（就是由1、0转化为电流强弱来进行传输,到达目的地后在转化为1、0，也就是我们常说的数模转换与模数转换）。这一层的数据叫做比特。</p>
<p>2、<strong>数据链路层：帧</strong></p>
<p>定义了如何让格式化数据以进行传输，以及如何让控制对物理介质的访问。这一层通常还提供错误检测和纠正，以确保数据的可靠传输。</p>
<p>3、<strong>网络层：数据报</strong></p>
<p>在位于不同地理位置的网络中的两个主机系统之间提供连接和路径选择。Internet的发展使得从世界各站点访问信息的用户数大大增加，而网络层正是管理这种连接的层。</p>
<p>4、运输层：报文段/用户数据报</p>
<p>定义了一些传输数据的协议和端口号（WWW端口80等），如：<br>TCP（transmission control protocol –传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据）<br>UDP（user datagram protocol–用户数据报协议，与TCP特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如QQ聊天数据就是通过这种方式传输的）。 主要是将从下层接收的数据进行分段和传输，到达目的地址后再进行重组。常常把这一层数据叫做段。</p>
<p>5、会话层：</p>
<p>通过运输层（端口号：传输端口与接收端口）建立数据传输的通路。主要在你的系统之间发起会话或者接受会话请求（设备之间需要互相认识可以是IP也可以是MAC或者是主机名）</p>
<p>6、表示层：</p>
<p>可确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。例如，PC程序与另一台计算机进行通信，其中一台计算机使用扩展二一十进制交换码（EBCDIC），而另一台则使用美国信息交换标准码（ASCII）来表示相同的字符。如有必要，表示层会通过使用一种通格式来实现多种数据格式之间的转换。</p>
<p>7.应用层：报文</p>
<h3 id="五层协议分层（实际应用，OSI出来的较晚）"><a href="#五层协议分层（实际应用，OSI出来的较晚）" class="headerlink" title="五层协议分层（实际应用，OSI出来的较晚）"></a>五层协议分层（实际应用，OSI出来的较晚）</h3><p>1、第五层——应用层(application layer)</p>
<pre><code>应用层(application layer)：是体系结构中的最高。直接为用户的应用进程（例如电子邮件、文件传输和终端仿真）提供服务。
在因特网中的应用层协议很多，如支持万维网应用的HTTP协议，支持电子邮件的SMTP协议，支持文件传送的FTP协议，DNS，POP3，SNMP，Telnet等等。</code></pre><p>2、第四层——运输层(transport layer)</p>
<pre><code>运输层(transport layer)：负责向两个主机中进程之间的通信提供服务。由于一个主机可同时运行多个进程，因此运输层有复用和分用的功能
复用，就是多个应用层进程可同时使用下面运输层的服务。
分用，就是把收到的信息分别交付给上面应用层中相应的进程。
运输层主要使用以下两种协议： 
(1) 传输控制协议TCP(Transmission Control Protocol)：面向连接的，数据传输的单位是报文段，能够提供可靠的交付。 
(2) 用户数据包协议UDP(User Datagram Protocol)：无连接的，数据传输的单位是用户数据报，不保证提供可靠的交付，只能提供“尽最大努力交付”。</code></pre><p>3、第三层——网络层(network layer)</p>
<pre><code>网络层(network layer)主要包括以下两个任务：
(1) 负责为分组交换网上的不同主机提供通信服务。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组或包进行传送。在TCP/IP体系中，由于网络层使用IP协议，因此分组也叫做IP数据报，或简称为数据报。
(2) 选中合适的路由，使源主机运输层所传下来的分组，能够通过网络中的路由器找到目的主机。
协议：IP,ICMP,IGMP,ARP,RARP</code></pre><p>4、第二层——数据链路层(data link layer)</p>
<pre><code>数据链路层(data link layer)：常简称为链路层，我们知道，两个主机之间的数据传输，总是在一段一段的链路上传送的，也就是说，在两个相邻结点之间传送数据是直接传送的(点对点)，这时就需要使用专门的链路层的协议。
在两个相邻结点之间传送数据时，数据链路层将网络层交下来的IP数据报组装成帧(framing)，在两个相邻结点之间的链路上“透明”地传送帧中的数据。
每一帧包括数据和必要的控制信息(如同步信息、地址信息、差错控制等)。典型的帧长是几百字节到一千多字节。
注：”透明”是一个很重要的术语。它表示，某一个实际存在的事物看起来却好像不存在一样。”在数据链路层透明传送数据”表示无力什么样的比特组合的数据都能够通过这个数据链路层。因此，对所传送的数据来说，这些数据就“看不见”数据链路层。或者说，数据链路层对这些数据来说是透明的。 
(1)在接收数据时，控制信息使接收端能知道一个帧从哪个比特开始和到哪个比特结束。这样，数据链路层在收到一个帧后，就可从中提取出数据部分，上交给网络层。 
(2)控制信息还使接收端能检测到所收到的帧中有无差错。如发现有差错，数据链路层就简单地丢弃这个出了差错的帧，以免继续传送下去白白浪费网络资源。如需改正错误，就由运输层的TCP协议来完成。</code></pre><p>5、第一层——物理层(physical layer)</p>
<pre><code>物理层(physical layer)：在物理层上所传数据的单位是比特。物理层的任务就是透明地传送比特流。</code></pre><p>6、数据在各层之间的传递过程</p>
<p>![]</p>
]]></content>
  </entry>
  <entry>
    <title>Vue修饰符</title>
    <url>/2020/06/19/Vue%E4%BF%AE%E9%A5%B0%E7%AC%A6/</url>
    <content><![CDATA[<h2 id="Vue修饰符"><a href="#Vue修饰符" class="headerlink" title="Vue修饰符"></a>Vue修饰符</h2><ul>
<li>.lazy:<br>v-modeil不用多说，输入框改变，这个数据就会改变，lazy这个修饰符会在光标离开input框才会更新数据：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">"text"</span> v-model.lazy=<span class="string">"value"</span>&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>.trim:<br>输入框过滤首尾的空格：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">"text"</span> v-model.trim=<span class="string">"value"</span>&gt;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<ul>
<li>.number:<br>先输入数字就会限制输入只能是数字，先字符串就相当于没有加number，注意，不是输入框不能输入字符串，是这个数据是数字：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">"text"</span> v-model.number=<span class="string">"value"</span>&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>.stop:<br>阻止事件冒泡，相当于调用了event.stopPropagation()方法。这个应该不需要解释：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;button @click.stop=<span class="string">"test"</span>&gt;test&lt;<span class="regexp">/button&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>.passive:<br>其实我不怎么理解，官网解释说可以提升移动端的性能，查了查，大概解释就是每次滚动都会有一个默认事件触发，加了这个就是告诉浏览器，不需要查询，不需要触发这个默认事件preventDefault：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发 --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 而不会等待 <span class="string">`onScroll`</span> 完成 --&gt;</span><br><span class="line"></span><br><span class="line"> &lt;!-- 这其中包含 <span class="string">`event.preventDefault()`</span> 的情况 --&gt;</span><br><span class="line"></span><br><span class="line">&lt;div v-on:scroll.passive=<span class="string">"onScroll"</span>&gt;...&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>.prevent:<br>阻止默认行为，相当于调用了event.preventDefault()方法，比如表单的提交、a标签的跳转就是默认事件：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;a @click.prevent=<span class="string">"test"</span>&gt;test&lt;<span class="regexp">/a&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>.slef:<br>只有元素本身触发时才触发方法，就是只有点击元素本身才会触发。比如一个div里面有个按钮，div和按钮都有事件，我们点击按钮，div绑定的方法也会触发，如果div的click加上self，只有点击到div的时候才会触发，变相的算是阻止冒泡：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div @click.self=<span class="string">"test"</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>.once:<br>只能用一次，无论点击几次，执行一次之后都不会再执行：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div @click.once=<span class="string">"test"</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>.capture:<br>事件的完整机制是捕获-目标-冒泡，事件触发是目标往外冒泡，比如：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div @click=<span class="string">"test(1)"</span>&gt;  <span class="xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"test(2)"</span>&gt;</span>test<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">顺序是2 1，capture的作用就是让这个顺序相反：</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;div @click.capture="test(1)"&gt;  &lt;button @click="test(2)"&gt;test&lt;/</span>button&gt;&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>.native: 组件绑定当前组件的事件是不会触发的，需要用native才能触发：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;My-component @click=<span class="string">"shout(3)"</span>&gt;&lt;<span class="regexp">/My-component&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>.keyCode:<br>监听按键的指令，具体可以查看vue的键码对应表：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">"text"</span> @keyup.enter=<span class="string">"test(1)"</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;button @click.enter=<span class="string">"test(1)"</span>&gt;test&lt;<span class="regexp">/button&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>.exact:<br>系统修饰键，只有按着这个键然后用鼠标点击才会触发，官网解释：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- 即使 Alt 或 Shift 被一同按下时也会触发 --&gt;</span><br><span class="line"></span><br><span class="line"> &lt;button @click.ctrl=<span class="string">"onClick"</span>&gt;A&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;!-- 有且只有 Ctrl 被按下的时候才触发 --&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;button @click.ctrl.exact="onCtrlClick"&gt;A&lt;/</span>button&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 没有任何系统修饰符被按下的时候才触发 --&gt;</span><br><span class="line">&lt;button @click.exact=<span class="string">"onClick"</span>&gt;A&lt;<span class="regexp">/button&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>.sync:<br>对prop进行双向绑定，个人暂时用不习惯：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//父组件</span></span><br><span class="line"></span><br><span class="line">&lt;fa-comp :fatest.sync=<span class="string">"test"</span>&gt;&lt;<span class="regexp">/fa-comp&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/子组件</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">this.$emit('update:fatest,sontest);</span></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>css</title>
    <url>/2020/06/13/css/</url>
    <content><![CDATA[<h1 id="CSS相关"><a href="#CSS相关" class="headerlink" title="CSS相关"></a>CSS相关</h1><p>1.官方文档 w3.org All Status And Drwafts(所有宏观上的修改版本等) Full property table(所有css的属性详解)</p>
<p>2.mdn中文web(官方文档中文翻译)</p>
<p>3.查询浏览器css样式兼容性网站   <a href="http://www.caniuse.com" target="_blank" rel="noopener">www.caniuse.com</a></p>
<p>4.如果把样式表单独抽离为css文件,最好能声明charset  @charset “utf-8”;</p>
<p>5.用@import的方式引入css样式表,但效率没有link高</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    @<span class="keyword">import</span> url(css样式表)</span><br><span class="line">&lt;<span class="regexp">/style&gt;</span></span><br></pre></td></tr></table></figure>

<p>6.尽量不要用标签的属性去控制样式.例如img的width属性</p>
<p>7.font-family的设置可以设置多个,是为了防止服务器的C/Windows/fonts里没有写的字体</p>
<p>8.css基线差不多是HTML字母x最底部</p>
<p>9.text-transform:lowercase</p>
<p>10.dl(define list),dt(define terms),dd(define description)</p>
<p>11.tr(table row), th(table head), td(table data)</p>
<p>12.css的两大特性:继承(inherit),层叠(相同选择器,!important&gt;style&gt;id&gt;类&gt;元素)</p>
<p>13.改变列表的前面默认块 list-style-type:none</p>
<p>14.table标签下边框合并border-collapse:collapse(设置边框为1中间会变成2)</p>
<p>15.margin:auto 浏览器会把剩余的块分配给auto的那一侧</p>
<p>16.margin-top的百分比是按照父元素的宽度,top是父元素的高度,transform:translateY(-50%)是按照自己的</p>
<p>17.background-image: url(), url()</p>
<p>18.css sprite 多个小图片合成到一个大图片(请求多次图片对于服务器压力大)</p>
<p>19.seo优化 text-indent :-999px;</p>
]]></content>
  </entry>
  <entry>
    <title>WebPack</title>
    <url>/2020/06/19/WebPack/</url>
    <content><![CDATA[<h1 id="1-核心概念"><a href="#1-核心概念" class="headerlink" title="1. 核心概念"></a>1. 核心概念</h1><blockquote>
<p>本质上，webpack 是一个现代 JavaScript 应用程序的静态<br>模块打包器(module bundler)。当 webpack 处理应用程序<br>时它会递归地构建一个依赖关系图(dependency graph)，其<br>中包含应用程序需要的每个模块，然后将所有这些模块打包<br>成一个或多个 bundle。</p>
</blockquote>
<p>&nbsp;</p>
<h2 id="1-1-入口（entry）"><a href="#1-1-入口（entry）" class="headerlink" title="1.1. 入口（entry）"></a>1.1. 入口（entry）</h2><blockquote>
<p>入口起点(entry point)指示 webpack 应该使用哪个模块，来作为构建其内部依赖图的开始。进入入口起点后，webpack 会找出有setting.json哪些模块和库是入口起点（直接和间接）依赖的。</p>
</blockquote>
<ol>
<li>webpack 配置中配置 entry 属性</li>
<li>默认值为 ./src</li>
<li>webpack.config.js</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./path/to/my/entry/file.js'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<br/>

<a id="more"></a>

<h2 id="1-2-出口（output）"><a href="#1-2-出口（output）" class="headerlink" title="1.2. 出口（output）"></a>1.2. 出口（output）</h2><br/>
output 属性告诉 webpack 在哪里输出它所创建的 bundles，以及如何命名这些文件。基本上，整个应用程序结构，都会被编译到你指定的输出路径的文件夹中。
1.webpack 配置中配置 entry 属性
2.默认值为./dist
3.webpack.config.js

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./path/to/my/entry/file.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'my-first-webpack.bundle.js'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<br/>

<h2 id="1-3-loader"><a href="#1-3-loader" class="headerlink" title="1.3. loader"></a>1.3. loader</h2><blockquote>
<p>loader 让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）。loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块，然后你就可以利用 webpack 的打包能力，对它们进行处理。</p>
</blockquote>
<blockquote>
<p>本质上，webpack loader 将所有类型的文件，转换为应用程序的依赖图（和最终的 bundle）可以直接引用的模块。</p>
</blockquote>
<ol>
<li><p><strong>test</strong> 属性,用于标识出应该被对应的loader进行转换的某个或某些文件。</p>
</li>
<li><p><strong>use</strong> 属性，表示进行转换时，应该使用哪个loader。</p>
</li>
<li><p>webpack.config.js</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'my-first-webpack.bundle.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123; <span class="attr">test</span>: <span class="regexp">/\.txt$/</span>, <span class="attr">use</span>: <span class="string">'raw-loader'</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = config;</span><br></pre></td></tr></table></figure>
<p><strong>“嘿，webpack 编译器，当你碰到「在 require()/import 语句中被解析为 ‘.txt’ 的路径」时，在你对它打包之前，先使用 raw-loader 转换一下。”</strong></p>
<br/>

<h2 id="1-4-插件（plugins）"><a href="#1-4-插件（plugins）" class="headerlink" title="1.4. 插件（plugins）"></a>1.4. 插件（plugins）</h2><blockquote>
<p>想要使用一个插件，你只需要 require() 它，然后把它添加到 plugins 数组中。多数插件可以通过选项(option)自定义。你也可以在一个配置文件中因为不同目的而多次使用同一个插件，这时需要通过使用 new 操作符来创建它的一个实例。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>); <span class="comment">// 通过 npm 安装</span></span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>); <span class="comment">// 用于访问内置插件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123; <span class="attr">test</span>: <span class="regexp">/\.txt$/</span>, <span class="attr">use</span>: <span class="string">'raw-loader'</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;<span class="attr">template</span>: <span class="string">'./src/index.html'</span>&#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = config;</span><br></pre></td></tr></table></figure>
<br/>

<h2 id="1-5-模式"><a href="#1-5-模式" class="headerlink" title="1.5. 模式"></a>1.5. 模式</h2><blockquote>
<p>通过选择 development 或 production 之中的一个，来设置 mode 参数，你可以启用相应模式下的 webpack 内置的优化</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">'production'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<br/>

<h1 id="2-入口起点（entry-points）"><a href="#2-入口起点（entry-points）" class="headerlink" title="2. 入口起点（entry points）"></a>2. 入口起点（entry points）</h1><br/>

<h2 id="2-1-单个入口"><a href="#2-1-单个入口" class="headerlink" title="2.1. 单个入口"></a>2.1. 单个入口</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  entry: <span class="string">'./path/to/my/entry/file.js'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = config;</span><br></pre></td></tr></table></figure>
<br/>

<h2 id="2-2-多个入口"><a href="#2-2-多个入口" class="headerlink" title="2.2. 多个入口"></a>2.2. 多个入口</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    app: <span class="string">'./src/app.js'</span>,</span><br><span class="line">    vendors: <span class="string">'./src/vendors.js'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>“可扩展的 webpack 配置”是指，可重用并且可以与其他配置组合使用。这是一种流行的技术，用于将关注点(concern)从环境(environment)、构建目标(build target)、运行时(runtime)中分离。然后使用专门的工具（如 webpack-merge）将它们合并。</p>
</blockquote>
<br/>

<h2 id="2-3-常见场景"><a href="#2-3-常见场景" class="headerlink" title="2.3. 常见场景"></a>2.3. 常见场景</h2><h4 id="2-3-0-1-分离-应用程序-app-和-第三方库-vendor-入口"><a href="#2-3-0-1-分离-应用程序-app-和-第三方库-vendor-入口" class="headerlink" title="2.3.0.1. 分离 应用程序(app) 和 第三方库(vendor) 入口"></a>2.3.0.1. 分离 应用程序(app) 和 第三方库(vendor) 入口</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    app: <span class="string">'./src/app.js'</span>,</span><br><span class="line">    vendors: <span class="string">'./src/vendors.js'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<br/>

<blockquote>
<p>这是什么？从表面上看，这告诉我们 webpack 从 app.js 和 vendors.js 开始创建依赖图(dependency graph)。这些依赖图是彼此完全分离、互相独立的（每个 bundle 中都有一个 webpack 引导(bootstrap)）。这种方式比较常见于，只有一个入口起点（不包括 vendor）的单页应用程序(single page application)中。</p>
</blockquote>
<blockquote>
<p>为什么？此设置允许你使用 CommonsChunkPlugin 从「应用程序 bundle」中提取 vendor 引用(vendor reference) 到 vendor bundle，并把引用 vendor 的部分替换为 <strong>webpack_require</strong>() 调用。如果应用程序 bundle 中没有 vendor 代码，那么你可以在 webpack 中实现被称为长效缓存的通用模式。</p>
</blockquote>
<h2 id="2-4-多页面应用程序"><a href="#2-4-多页面应用程序" class="headerlink" title="2.4. 多页面应用程序"></a>2.4. 多页面应用程序</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    pageOne: <span class="string">'./src/pageOne/index.js'</span>,</span><br><span class="line">    pageTwo: <span class="string">'./src/pageTwo/index.js'</span>,</span><br><span class="line">    pageThree: <span class="string">'./src/pageThree/index.js'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<br/>

<blockquote>
<p>这是什么？我们告诉 webpack 需要 3 个独立分离的依赖图（如上面的示例）。</p>
</blockquote>
<blockquote>
<p>为什么？在多页应用中，（译注：每当页面跳转时）服务器将为你获取一个新的 HTML 文档。页面重新加载新文档，并且资源被重新下载。然而，这给了我们特殊的机会去做很多事：</p>
</blockquote>
<blockquote>
<p>使用 CommonsChunkPlugin 为每个页面间的应用程序共享代码创建 bundle。由于入口起点增多，多页应用能够复用入口起点之间的大量代码/模块，从而可以极大地从这些技术中受益。</p>
</blockquote>
<h1 id="3-输出"><a href="#3-输出" class="headerlink" title="3. 输出"></a>3. 输出</h1><blockquote>
<p>配置 output 选项可以控制 webpack 如何向硬盘写入编译文件。注意，即使可以存在多个入口起点，但只指定一个输出配置。</p>
</blockquote>
<h2 id="3-1-用法（usage）"><a href="#3-1-用法（usage）" class="headerlink" title="3.1. 用法（usage）"></a>3.1. 用法（usage）</h2><blockquote>
<p>在 webpack 中配置 output 属性的最低要求是，将它的值设置为一个对象，包括以下两点：</p>
<ul>
<li>filename 用于输出文件的文件名。</li>
<li>目标输出目录 path 的绝对路径。</li>
</ul>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">    path: <span class="string">'/home/proj/public/assets'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = config;</span><br></pre></td></tr></table></figure>
<br/>

<h2 id="3-2-多个入口起点"><a href="#3-2-多个入口起点" class="headerlink" title="3.2. 多个入口起点"></a>3.2. 多个入口起点</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">	<span class="keyword">const</span> config = &#123;</span><br><span class="line">	  entry: &#123;</span><br><span class="line">	    app: <span class="string">'./src/app.js'</span>,</span><br><span class="line">	    search: <span class="string">'./src/search.js'</span></span><br><span class="line">	  &#125;,</span><br><span class="line">	  output: &#123;</span><br><span class="line">	    filename: <span class="string">'[name].js'</span>,</span><br><span class="line">	    path: __dirname + <span class="string">'/dist'</span></span><br><span class="line">	  &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入到硬盘：./dist/app.js, ./dist/search.js</span></span><br></pre></td></tr></table></figure>
<br/>

<h2 id="3-3-高级进阶"><a href="#3-3-高级进阶" class="headerlink" title="3.3. 高级进阶"></a>3.3. 高级进阶</h2><h4 id="3-3-0-2-以下是使用-CDN-和资源-hash-的复杂示例："><a href="#3-3-0-2-以下是使用-CDN-和资源-hash-的复杂示例：" class="headerlink" title="3.3.0.2. 以下是使用 CDN 和资源 hash 的复杂示例："></a>3.3.0.2. 以下是使用 CDN 和资源 hash 的复杂示例：</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">  path: <span class="string">"/home/proj/cdn/assets/[hash]"</span>,</span><br><span class="line">  publicPath: <span class="string">"http://cdn.example.com/assets/[hash]/"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br/>

<blockquote>
<p>在编译时不知道最终输出文件的 publicPath 的情况下，publicPath 可以留空，并且在入口起点文件运行时动态设置。如果你在编译时不知道 publicPath，你可以先忽略它，并且在入口起点设置 <strong>webpack_public_path</strong>。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">__webpack_public_path__ = myRuntimePublicPath</span><br><span class="line"></span><br><span class="line"><span class="comment">// 剩余的应用程序入口</span></span><br></pre></td></tr></table></figure>

<h6 id="3-3-0-2-0-1-publicPath-扩展"><a href="#3-3-0-2-0-1-publicPath-扩展" class="headerlink" title="3.3.0.2.0.1. publicPath(扩展)"></a>3.3.0.2.0.1. publicPath(扩展)</h6><blockquote>
<p>webpack 提供一个非常有用的配置，该配置能帮助你为项目中的所有资源指定一个基础路径，它被称为公共路径(publicPath)。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">output.publicPath = <span class="string">'/dist/'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// image</span></span><br><span class="line">options: &#123;</span><br><span class="line"> 	name: <span class="string">'img/[name].[ext]?[hash]'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最终图片的访问路径为</span></span><br><span class="line">output.publicPath + <span class="string">'img/[name].[ext]?[hash]'</span> = <span class="string">'/dist/img/[name].[ext]?[hash]'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// js output.filename</span></span><br><span class="line">output: &#123;</span><br><span class="line">	filename: <span class="string">'[name].js'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 最终js的访问路径为</span></span><br><span class="line">output.publicPath + <span class="string">'[name].js'</span> = <span class="string">'/dist/[name].js'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// extract-text-webpack-plugin css</span></span><br><span class="line"><span class="keyword">new</span> ExtractTextPlugin(&#123;</span><br><span class="line">	filename: <span class="string">'style.[chunkhash].css'</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 最终css的访问路径为</span></span><br><span class="line">output.publicPath + <span class="string">'style.[chunkhash].css'</span> = <span class="string">'/dist/style.[chunkhash].css'</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个最终静态资源访问路径在使用html-webpack-plugin打包后得到的html中可以看到。所以publicPath设置成相对路径后，相对路径是相对于build之后的index.html的，例如，如果设置publicPath: ‘./dist/‘，则打包后js的引用路径为./dist/main.js，但是这里有一个问题，相对路径在访问本地时可以，但是如果将静态资源托管到CDN上则访问路径显然不能使用相对路径，但是如果将publicPath设置成/，则打包后访问路径为localhost:8080/dist/main.js，本地无法访问.<br>所以这里需要在上线时候手动更改publicPath，感觉不是很方便，但是不知道该如何解决…</p>
</blockquote>
<p><strong>一般情况下publicPath应该以’/‘结尾，而其他loader或插件的配置不要以’/‘开头</strong><br><br/></p>
<h1 id="4-模式"><a href="#4-模式" class="headerlink" title="4. 模式"></a>4. 模式</h1><blockquote>
<p>提供 mode 配置选项，告知 webpack 使用相应模式的内置优化。</p>
</blockquote>
<ul>
<li>development<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.development.config.js</span></span><br><span class="line">	<span class="built_in">module</span>.exports = &#123;</span><br><span class="line">	+ mode: <span class="string">'development'</span></span><br><span class="line">	- plugins: [</span><br><span class="line">	-   <span class="keyword">new</span> webpack.NamedModulesPlugin(),</span><br><span class="line">	-   <span class="keyword">new</span> webpack.DefinePlugin(&#123; <span class="string">"process.env.NODE_ENV"</span>: <span class="built_in">JSON</span>.stringify(<span class="string">"development"</span>) &#125;),</span><br><span class="line">	- ]</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></li>
<li>production<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.production.config.js</span></span><br><span class="line">	<span class="built_in">module</span>.exports = &#123;</span><br><span class="line">	+  mode: <span class="string">'production'</span>,</span><br><span class="line">	-  plugins: [</span><br><span class="line">	-    <span class="keyword">new</span> UglifyJsPlugin(<span class="comment">/* ... */</span>),</span><br><span class="line">	-    <span class="keyword">new</span> webpack.DefinePlugin(&#123; <span class="string">"process.env.NODE_ENV"</span>: <span class="built_in">JSON</span>.stringify(<span class="string">"production"</span>) &#125;),</span><br><span class="line">	-    <span class="keyword">new</span> webpack.optimize.ModuleConcatenationPlugin(),</span><br><span class="line">	-    <span class="keyword">new</span> webpack.NoEmitOnErrorsPlugin()</span><br><span class="line">	-  ]</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<br/>

</li>
</ul>
<h1 id="5-loader"><a href="#5-loader" class="headerlink" title="5. loader"></a>5. loader</h1><blockquote>
<p>loader 用于对模块的源代码进行转换。loader 可以使你在 import 或”加载”模块时预处理文件。因此，loader 类似于其他构建工具中“任务(task)”，并提供了处理前端构建步骤的强大方法。loader 可以将文件从不同的语言（如 TypeScript）转换为 JavaScript，或将内联图像转换为 data URL。loader 甚至允许你直接在 JavaScript 模块中 import CSS文件！</p>
</blockquote>
<h2 id="5-1-示例"><a href="#5-1-示例" class="headerlink" title="5.1. 示例"></a>5.1. 示例</h2><p>例如，你可以使用 loader 告诉 webpack 加载 CSS 文件，或者将 TypeScript 转为 JavaScript。然后指示 webpack 对每个 .css 使用 css-loader，以及对所有 .ts 文件使用 ts-loader：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123; <span class="attr">test</span>: <span class="regexp">/\.css$/</span>, <span class="attr">use</span>: <span class="string">'css-loader'</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">test</span>: <span class="regexp">/\.ts$/</span>, <span class="attr">use</span>: <span class="string">'ts-loader'</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<br/>

<h2 id="5-2-使用loader"><a href="#5-2-使用loader" class="headerlink" title="5.2. 使用loader"></a>5.2. 使用loader</h2><p>在你的应用程序中，有三种使用 loader 的方式：</p>
<p>配置（推荐）：在 webpack.config.js 文件中指定 loader。<br>内联：在每个 import 语句中显式指定 loader。<br>CLI：在 shell 命令中指定它们。<br><br/></p>
<h4 id="5-2-0-3-配置（configuration）"><a href="#5-2-0-3-配置（configuration）" class="headerlink" title="5.2.0.3. 配置（configuration）"></a>5.2.0.3. 配置（configuration）</h4><blockquote>
<p>module.rules 允许你在 webpack 配置中指定多个 loader。 这是展示 loader 的一种简明方式，并且有助于使代码变得简洁。同时让你对各个 loader 有个全局概览：</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">      use: [</span><br><span class="line">        &#123; <span class="attr">loader</span>: <span class="string">'style-loader'</span> &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          loader: <span class="string">'css-loader'</span>,</span><br><span class="line">          options: &#123;</span><br><span class="line">            modules: <span class="literal">true</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br/>

<h4 id="5-2-0-4-内联"><a href="#5-2-0-4-内联" class="headerlink" title="5.2.0.4. 内联"></a>5.2.0.4. 内联</h4><blockquote>
<p>可以在 import 语句或任何等效于 “import” 的方式中指定 loader。使用 ! 将资源中的 loader 分开。分开的每个部分都相对于当前目录解析。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Styles <span class="keyword">from</span> <span class="string">'style-loader!css-loader?modules!./styles.css'</span>;</span><br></pre></td></tr></table></figure>

<p>通过前置所有规则及使用 !，可以对应覆盖到配置中的任意 loader。</p>
<p>选项可以传递查询参数，例如 ?key=value&amp;foo=bar，或者一个 JSON 对象，例如 ?{“key”:”value”,”foo”:”bar”}。</p>
<p>尽可能使用 module.rules，因为这样可以减少源码中的代码量，并且可以在出错时，更快地调试和定位 loader 中的问题。</p>
<h4 id="5-2-0-5-CLI-命令行操作"><a href="#5-2-0-5-CLI-命令行操作" class="headerlink" title="5.2.0.5. CLI(命令行操作)"></a>5.2.0.5. CLI(命令行操作)</h4><br/>

<h2 id="5-3-loader特性"><a href="#5-3-loader特性" class="headerlink" title="5.3. loader特性"></a>5.3. loader特性</h2><ul>
<li>loader 支持链式传递。能够对资源使用流水线(pipeline)。一组- 链式的 loader 将按照相反的顺序执行。loader 链中的第一个 - - loader 返回值给下一个 loader。在最后一个 loader，返回 webpack 所预期的 JavaScript。</li>
<li>loader 可以是同步的，也可以是异步的。</li>
<li>loader 运行在 Node.js 中，并且能够执行任何可能的操作。</li>
<li>loader 接收查询参数。用于对 loader 传递配置。</li>
<li>loader 也能够使用 options 对象进行配置。</li>
<li>除了使用 package.json 常见的 main 属性，还可以将普通的 npm 模块导出为 loader，做法是在 package.json 里定义一个 loader 字段。</li>
<li>插件(plugin)可以为 loader 带来更多特性。</li>
<li>loader 能够产生额外的任意文件。</li>
</ul>
<h2 id="5-4-解析-loader"><a href="#5-4-解析-loader" class="headerlink" title="5.4. 解析 loader"></a>5.4. 解析 loader</h2><blockquote>
<p>loader 遵循标准的模块解析。多数情况下，loader 将从模块路径（通常将模块路径认为是 npm install, node_modules）解析。</p>
</blockquote>
<blockquote>
<p>loader 模块需要导出为一个函数，并且使用 Node.js 兼容的 JavaScript 编写。通常使用 npm 进行管理，但是也可以将自定义 loader 作为应用程序中的文件。按照约定，loader 通常被命名为 xxx-loader（例如 json-loader）。</p>
</blockquote>
<br/>

<h1 id="6-插件"><a href="#6-插件" class="headerlink" title="6. 插件"></a>6. 插件</h1><p><strong>插件目的在于解决 loader 无法实现的其他事。</strong></p>
<ol>
<li>apply 属性会被 webpack compiler 调用，并且 compiler 对象可在整个编译生命周期访问。</li>
</ol>
<h1 id="7-配置分离（-merge）"><a href="#7-配置分离（-merge）" class="headerlink" title="7. 配置分离（-merge）"></a>7. 配置分离（-merge）</h1><p>我们在根目录下创建config文件夹，并创建四个配置文件：</p>
<ul>
<li>webpack.comm.js 公共环境的配置文件</li>
<li>webpack.development.js 开发环境下的配置文件</li>
<li>webpack.production.js 生产环境下的配置文件</li>
<li>webpack.parts.js 各个配置零件的配置文件</li>
</ul>
<p><strong>webpack-merge做了两件事：它允许连接数组并合并对象，而不是覆盖组合。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> merge = <span class="built_in">require</span>(<span class="string">"webpack-merge"</span>);</span><br><span class="line">merge(</span><br><span class="line">    &#123;<span class="attr">a</span> : [<span class="number">1</span>],<span class="attr">b</span>:<span class="number">5</span>,<span class="attr">c</span>:<span class="number">20</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">a</span> : [<span class="number">2</span>],<span class="attr">b</span>:<span class="number">10</span>, <span class="attr">d</span>: <span class="number">421</span>&#125;</span><br><span class="line">)</span><br><span class="line"><span class="comment">//合并后的结果</span></span><br><span class="line">&#123;<span class="attr">a</span> : [<span class="number">1</span>,<span class="number">2</span>] ,<span class="attr">b</span> :<span class="number">10</span> , <span class="attr">c</span> : <span class="number">20</span>, <span class="attr">d</span> : <span class="number">421</span>&#125;</span><br></pre></td></tr></table></figure>

<h1 id="8-外部扩展（extrenals）"><a href="#8-外部扩展（extrenals）" class="headerlink" title="8. 外部扩展（extrenals）"></a>8. 外部扩展（extrenals）</h1><blockquote>
<p>防止将某些 import 的包(package)打包到 bundle 中，而是在运行时(runtime)再去从外部获取这些扩展依赖(external dependencies)。</p>
</blockquote>
<p><strong>例如，从 CDN 引入 jQuery，而不是把它打包.</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//index.html</span></span><br><span class="line">&lt;script</span><br><span class="line">  src=<span class="string">"https://code.jquery.com/jquery-3.1.0.js"</span></span><br><span class="line">  integrity=<span class="string">"sha256-slogkvB1K3VOkzAI8QITxV3VzpOnkeNVsKvtkYLMjfk="</span></span><br><span class="line">  crossorigin=<span class="string">"anonymous"</span>&gt;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/webpack.config.js</span></span><br><span class="line"><span class="regexp">externals: &#123;</span></span><br><span class="line"><span class="regexp">  jquery: 'jQuery'</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/这样就剥离了那些不需要改动的依赖模块，换句话，下面展示的代码还可以正常运行：</span></span><br><span class="line"><span class="regexp">import $ from 'jquery';</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">$('.my-element').animate(...);</span></span><br></pre></td></tr></table></figure>

<h2 id="tableTest"><a href="#tableTest" class="headerlink" title="tableTest"></a>tableTest</h2><table>
<thead>
<tr>
<th>姓名(默认左对齐))</th>
<th align="center">技能（两遍都有是中间）</th>
<th align="right">排行（右侧冒号右对齐）</th>
</tr>
</thead>
<tbody><tr>
<td>刘备</td>
<td align="center">哭</td>
<td align="right">大哥</td>
</tr>
<tr>
<td>关羽</td>
<td align="center">打</td>
<td align="right">二哥</td>
</tr>
<tr>
<td>张飞</td>
<td align="center">骂</td>
<td align="right">三弟</td>
</tr>
</tbody></table>
]]></content>
  </entry>
  <entry>
    <title>css选择器</title>
    <url>/2020/06/14/css%E9%80%89%E6%8B%A9%E5%99%A8/</url>
    <content><![CDATA[<h1 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h1><p>1.后代元素选择器</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> <span class="selector-tag">p</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.直接子元素选择器</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &gt; <span class="selector-tag">span</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.属性选择器</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-attr">[title^=<span class="string">"one"</span>]</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.相邻兄弟选择器(后面元素)</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">span</span>+<span class="selector-tag">p</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.全部兄弟选择器(后面元素)</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">span</span>~<span class="selector-tag">p</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5.交集选择器</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-class">.one</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6.并集选择器</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span>, <span class="selector-class">.one</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>scoped穿透</title>
    <url>/2020/06/19/scoped%E7%A9%BF%E9%80%8F/</url>
    <content><![CDATA[<h1 id="Vue中的scoped和scoped穿透"><a href="#Vue中的scoped和scoped穿透" class="headerlink" title="Vue中的scoped和scoped穿透"></a>Vue中的scoped和scoped穿透</h1><h2 id="1-什么是scoped"><a href="#1-什么是scoped" class="headerlink" title="1.什么是scoped"></a>1.什么是scoped</h2><blockquote>
<p>在Vue文件中的style标签上有一个特殊的属性，scoped。当一个style标签拥有scoped属性时候，它的css样式只能用于当前的Vue组件，可以使组件的样式不相互污染。如果一个项目的所有style标签都加上了scoped属性，相当于实现了样式的模块化。</p>
</blockquote>
<h2 id="2-scoped的实现原理"><a href="#2-scoped的实现原理" class="headerlink" title="2.scoped的实现原理"></a>2.scoped的实现原理</h2><p>Vue中的scoped属性的效果主要是通过PostCss实现的。以下是转译前的代码:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;style scoped lang=<span class="string">"less"</span>&gt;</span><br><span class="line">    .example&#123;</span><br><span class="line">        color:red;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;<span class="regexp">/style&gt;</span></span><br><span class="line"><span class="regexp">&lt;template&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div class="example"&gt;scoped测试案例&lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br></pre></td></tr></table></figure>

<p>转译后:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">.example[data-v<span class="number">-5558831</span>a] &#123;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"example"</span> data-v<span class="number">-5558831</span>a&gt;scoped测试案例&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>既:PostCSS给一个组件中的所有dom添加了一个独一无二的动态属性，给css选择器额外添加一个对应的属性选择器，来选择组件中的dom,这种做法使得样式只作用于含有该属性的dom元素(组件内部的dom)。</p>
<p>总结：scoped的渲染规则：<br>给HTML的dom节点添加一个不重复的data属性(例如: data-v-5558831a)来唯一标识这个dom 元素<br>在每句css选择器的末尾(编译后生成的css语句)加一个当前组件的data属性选择器(例如：[data-v-5558831a])来私有化样式</p>
<h2 id="3-scoped穿透"><a href="#3-scoped穿透" class="headerlink" title="3.scoped穿透"></a>3.scoped穿透</h2><p>scoped看起来很好用，当时在Vue项目中，当我们引入第三方组件库时(如使用vue-awesome-swiper实现移动端轮播)，需要在局部组件中修改第三方组件库的样式，而又不想去除scoped属性造成组件之间的样式覆盖。这时我们可以通过特殊的方式穿透scoped。</p>
<p>stylus的样式穿透 使用&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 外层 &gt;&gt;&gt; 第三方组件 &#123;</span><br><span class="line">     样式  </span><br><span class="line"> &#125;</span><br><span class="line">.wrapper &gt;&gt;&gt; .swiper-pagination-bullet-active</span><br><span class="line"> background: #fff</span><br></pre></td></tr></table></figure>

<p>sass和less的样式穿透 使用/deep/</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">外层 &#x2F;deep&#x2F; 第三方组件 &#123;</span><br><span class="line">    样式</span><br><span class="line">&#125;</span><br><span class="line">.wrapper &#x2F;deep&#x2F; .swiper-pagination-bullet-active&#123;</span><br><span class="line">  background: #fff;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-在组件中修改第三方组件库样式的其它方法"><a href="#3-在组件中修改第三方组件库样式的其它方法" class="headerlink" title="3.在组件中修改第三方组件库样式的其它方法"></a>3.在组件中修改第三方组件库样式的其它方法</h2><hr/>

<p>在vue组建中使用两个style标签，一个加上scoped属性，一个不加scoped属性，把需要覆盖的css样式写在不加scoped属性的style标签里</p>
]]></content>
  </entry>
  <entry>
    <title>http和https</title>
    <url>/2020/06/19/http%E5%92%8Chttps/</url>
    <content><![CDATA[<h1 id="http和https的区别"><a href="#http和https的区别" class="headerlink" title="http和https的区别"></a>http和https的区别</h1><h2 id="一-http"><a href="#一-http" class="headerlink" title="一.http"></a>一.http</h2><p>定义：超文本传输协议，是互联网上应用最为广泛的一种网络协议，是一个客户端和服务端请求和应答的标准（tcp），用于从www服务器传输超文本到本地浏览器的传输协议。</p>
<h2 id="二-https"><a href="#二-https" class="headerlink" title="二.https"></a>二.https</h2><p>定义：在http的基础上，应用了ssl层（Secure Sockets Layer）。用于对http传输的数据进行加密。</p>
<h2 id="三-区别"><a href="#三-区别" class="headerlink" title="三.区别"></a>三.区别</h2><ol>
<li>https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。</li>
<li>http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</li>
<li>http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li>
<li>http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。<a id="more"></a>
<h2 id="四-https步骤"><a href="#四-https步骤" class="headerlink" title="四.https步骤"></a>四.https步骤</h2></li>
</ol>
<p>（1）客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接。</p>
<p>（2）Web服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。</p>
<p>（3）客户端的浏览器与Web服务器开始协商SSL连接的安全等级，也就是信息加密的等级。</p>
<p>（4）客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。</p>
<p>（5）Web服务器利用自己的私钥解密出会话密钥。</p>
<p>（6）Web服务器利用会话密钥加密与客户端之间的通信。</p>
<p><img src="" alt=""></p>
<h2 id="五-https的优点"><a href="#五-https的优点" class="headerlink" title="五.https的优点"></a>五.https的优点</h2><p>尽管HTTPS并非绝对安全，掌握根证书的机构、掌握加密算法的组织同样可以进行中间人形式的攻击，但HTTPS仍是现行架构下最安全的解决方案，主要有以下几个好处：</p>
<p>　　（1）使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；</p>
<p>　　（2）HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。</p>
<p>　　（3）HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。</p>
<p>　　（4）谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”。</p>
<h2 id="六-https的缺点"><a href="#六-https的缺点" class="headerlink" title="六.https的缺点"></a>六.https的缺点</h2><p>虽然说HTTPS有很大的优势，但其相对来说，还是存在不足之处的：</p>
<p>　　（1）HTTPS协议握手阶段比较费时，会使页面的加载时间延长近50%，增加10%到20%的耗电；</p>
<p>　　（2）HTTPS连接缓存不如HTTP高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响；</p>
<p>　　（3）SSL证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用。</p>
<p>　   （4）SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗。</p>
<p>　　（5）HTTPS协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。最关键的，SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。</p>
<h2 id="七-http切换到HTTPS"><a href="#七-http切换到HTTPS" class="headerlink" title="七.http切换到HTTPS"></a>七.http切换到HTTPS</h2><p>这里虽然将http切换为了https，还是建议保留http。所以我们在切换的时候可以做http和https的兼容，具体实现方式是，去掉页面链接中的http头部，这样可以自动匹配http头和https头。例如：将<a href="http://www.baidu.com改为//www.baidu.com。然后当用户从http的入口进入访问页面时，页面就是http，如果用户是从https的入口进入访问页面，页面即使https的。" target="_blank" rel="noopener">http://www.baidu.com改为//www.baidu.com。然后当用户从http的入口进入访问页面时，页面就是http，如果用户是从https的入口进入访问页面，页面即使https的。</a></p>
]]></content>
  </entry>
  <entry>
    <title>vue随笔</title>
    <url>/2020/06/20/vue%E9%9A%8F%E7%AC%94/</url>
    <content><![CDATA[<h2 id="随笔"><a href="#随笔" class="headerlink" title="随笔"></a>随笔</h2><p>1.方法是和实例绑定的， 方法和属性的区别</p>
<p>2.动态绑定classstyle</p>
<p>3.computed计算属性，有缓存 set和get</p>
<p>4.let和var 块级作用域， for循环 i经过块级改了，但是函数有作用域，所以用闭包</p>
<p>5.v-on什么时候能省略方法的（） 1.事件监听的时候，2没有参数、</p>
<p>6.组织事件冒泡@click.stop(详细参考vue修饰符.md)</p>
<p>7.v-if 需要有key来让虚拟dom区别数据显示</p>
<p>8.key的作用是高效的更新虚拟dom</p>
<a id="more"></a>

<p>9.数组.push（“aaa”,”bbb”,”ccc”）</p>
<p>10.js高阶函数 filter、map、reduce（function（前一个值，当前值），默认值）</p>
<p>11.脚手架的优势，子传父，监听命名可以用驼峰</p>
<p>12.props传值，可以直接用变量展示，但是如果需要改变值，则要放到data里(<strong>如果是对象或者数组则可以直接改变值!</strong>)</p>
<p>13.具名插槽，让name为left的slot替换 。</p>
<p>14.作用域插槽：父组件替换插槽的标签，但是内容还是由子组件提供。子组件：data template里 slot-scope</p>
<p>15.模块化开发<br>1.commonJS导出导入模块<br>   module.exports导出 require导入<br>2.es6<br>   export 导出 还有多种写法，default和class 等 import 导入</p>
<p>16.webpack<br>  webpack要想正常运行，依赖node环境。 node环境为了正常运行很多代码，需要很多包，所以需要npm工具</p>
<p>17.webpack中的entry 和output（中有path需要require（“path”））path.resolve(_dirname,”)</p>
<p>18.package.json dependencies是打包完所依赖的东西，devdependencies是开发过程中需要依赖的包<br>    为什么要有dev.config.js和localdev.config.js？ 因为<br>   为什么要用“scripts”省事，还有就是终端默认先选择全局的环境变量，用脚本就会优先使用局部的环境变量</p>
<p>19.webpack loader 是个数组，加载的顺序是从右边开始加载 cssloader styleloader fileloader imgloader   moudle  的rule下面  babelloader es6转es5 vueloader<br>    exclude：排除某些文件</p>
<p>20.vue最外层 引用 vue 组件模块，然后再template里放组件用来替换 <div id ="app"></div></p>
<p>21.vuecli 不支持适配ie8以下（可以改）</p>
<p>22.this.$router 是vuerouter对象 。 this. $route.params.abc（谁处于活跃对象就拿到谁）</p>
<p>23.mustache语法里不加this</p>
<p>24.路由的懒加载（因为同时放到一个里太大了）</p>
<p>25.路由的动态加载</p>
<p>26当一个内部函数被其外部函数之外的变量引用时，就形成了一个闭包。</p>
<p>27.new Promise((resolve,reject) =&gt; {<br>    $.ajax(function(){<br>“<a href="http://www.baidu.com&quot;},function(){" target="_blank" rel="noopener">www.baidu.com&quot;},function(){</a><br>    resolve(callback)<br>}<br>}).then()(<strong>最好了解一下event loop</strong>)</p>
<p>28.Vue.use（）其实是执行内部的install</p>
<p>29.所有的组件都继承自Vue类的原型</p>
<p>30.Object.defineProperty（“obj”“id”，“8015”）</p>
<p>31.导航守卫 是从哪里到哪里</p>
<p>32.vue router 传参用query或者params</p>
<p>33.vue router 执行事件用beforeEach</p>
<p>34.router的嵌套 （children）</p>
<p>35.生命周期函数， 在mounted之前才用template替换el，在之后用html替换el  一直执行update，destroy</p>
<p>36.keep-alive  activated</p>
<p>37.首页使用path属性记录离开时的路径，在beforerouteleave</p>
<p>38.mixin和组件 create的先后顺序 混入对象的钩子先触发</p>
<h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p>1.数组渲染，在中间插入元素，加key</p>
<p>2.computed计算属性，有缓存 set和get</p>
<p>3.静态资源压缩合并，如js代码合并，css代码合并，压缩图片等</p>
<p>4.静态资源缓存</p>
<p>5.使用 CDN 让资源加载更快</p>
<p>优化页面渲染：</p>
<p>1）减少HTTP请求；</p>
<p>2）减少DOM操作，多个操作尽量合并在一起执行（DocumentFragment）；</p>
<p>3）懒加载（图片懒加载、下拉加载更多）；</p>
<p>遵循规范</p>
<pre><code>require 是 AMD规范引入方式
import是es6的一个语法标准，如果要兼容浏览器的话必须转化成es5的语法</code></pre><p>调用时间</p>
<pre><code>require是运行时调用，所以require理论上可以运用在代码的任何地方
import是编译时调用，所以必须放在文件开头</code></pre><p>本质</p>
<pre><code>require是赋值过程，其实require的结果就是对象、数字、字符串、函数等，再把require的结果赋值给某个变量
import是解构过程，但是目前所有的引擎都还没有实现import，我们在node中使用babel支持ES6，也仅仅是将ES6转码为ES5再执行，import语法会被转码为require</code></pre>]]></content>
  </entry>
  <entry>
    <title>三次握手与四次挥手</title>
    <url>/2020/06/19/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</url>
    <content><![CDATA[<h1 id="三次握手与四次挥手"><a href="#三次握手与四次挥手" class="headerlink" title="三次握手与四次挥手"></a>三次握手与四次挥手</h1><h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><p>1.客户端向服务端发送ack（acknowledge character）确认字符报文。<br>2.服务端接收到报文，给客户端发送报文，告诉客户端已经接收到客户端的报文。<br>3.客户端再次给服务端发送报文，告诉服务端已经接收到服务端的报文。<br>4.tcp连接成立。</p>
<h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><p>1.（中断连接的一方可以是客户端也可以是服务端）客户端给服务端发中断请求。<br>2.客户端进入等待状态，服务端给其发送ack还有没有未传输完的数据。<br>3.等服务端发送完数据，给客户端发结束请求，客户端回应服务端，已经接收到请求。<br>4.服务端接收到客户端的ack请求，则关闭连接。客户端等2min关闭。</p>
]]></content>
  </entry>
  <entry>
    <title>内存</title>
    <url>/2020/06/19/%E5%86%85%E5%AD%98/</url>
    <content><![CDATA[<h2 id="栈空间"><a href="#栈空间" class="headerlink" title="栈空间"></a>栈空间</h2><p>1.在其中申请一块区域 通过指针(变量名)改变</p>
<p>2.基本数据类型都是放在栈空间</p>
<h2 id="堆空间"><a href="#堆空间" class="headerlink" title="堆空间"></a>堆空间</h2><p>1.引用类型,放到堆空间,但是内存地址是放在栈空间</p>
]]></content>
  </entry>
  <entry>
    <title>伪类&amp;伪元素</title>
    <url>/2020/06/14/%E4%BC%AA%E7%B1%BB&amp;%E4%BC%AA%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h2 id="伪类"><a href="#伪类" class="headerlink" title="伪类"></a>伪类</h2><p>1.目标伪类: 主要应用于锚点</p>
<p>:target(选中的锚点添加状态p:target是交集选择器)</p>
<p>2.目标状态伪类</p>
<p>:disabled, :enabled, :checked</p>
<p>3.动态伪类: 有顺序要求</p>
<p>a:link(未访问), a:visited(已访问), a:focus(tabindex属性=-1来去掉tab), a:hover(移动放上去), a:active(手指点下去)</p>
<p>4.结构伪类</p>
<ul>
<li>:nth-child(n), n是正整数(包括0).排行榜可以用-n+3来设置前三名</li>
<li>:nth-last-child(n), 倒着数</li>
<li>p:nth-of-type(n) 只找p的n数</li>
<li>p:nth-last-of-type(n) 倒着</li>
<li>:only-child (唯一子元素)</li>
<li>:only-of-type(唯一类型子元素)</li>
<li>:root(相当于html元素)</li>
<li>:empty</li>
<li>:not()</li>
</ul>
<h2 id="伪元素-区别伪类一般2个冒号-可以看成行内元素"><a href="#伪元素-区别伪类一般2个冒号-可以看成行内元素" class="headerlink" title="伪元素(区别伪类一般2个冒号,可以看成行内元素)"></a>伪元素(区别伪类一般2个冒号,可以看成行内元素)</h2><ol>
<li>p::first-letter</li>
<li>p::first-line</li>
<li>::before(利用content来在元素前添加东西(可以是url()))<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">span</span><span class="selector-pseudo">::before</span>&#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">"123"</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#0f0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>::after(利用content来在元素后添加东西(可以是url()))<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">span</span><span class="selector-pseudo">::before</span>&#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">"123"</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#0f0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>定位</title>
    <url>/2020/06/19/%E5%AE%9A%E4%BD%8D/</url>
    <content><![CDATA[<h1 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h1><h2 id="标准流-Normal-Flow"><a href="#标准流-Normal-Flow" class="headerlink" title="标准流(Normal Flow)"></a>标准流(Normal Flow)</h2><h3 id="坐标系-从左往右-从上到下"><a href="#坐标系-从左往右-从上到下" class="headerlink" title="坐标系:从左往右,从上到下"></a>坐标系:从左往右,从上到下</h3><p>1.默认情况下都是按照标准流排布</p>
<h3 id="原理-因为很难实现兄弟元素中间的层叠效果"><a href="#原理-因为很难实现兄弟元素中间的层叠效果" class="headerlink" title="原理:因为很难实现兄弟元素中间的层叠效果"></a>原理:因为很难实现兄弟元素中间的层叠效果</h3><p>1.static: 默认属性</p>
<p>2.relative: 相对定位,相对于原来的位置.但是原来的位置还是不会改变(类似于opacity:0).不会影响其他元素,没有脱离标准流</p>
<p><strong>left的百分比是相对于包含块</strong><br><strong>margin左右的百分比也是相对于包含块</strong><br><strong>transform:translate的百分比是相对于自己元素的</strong></p>
<p>3.absolute: 绝对定位,冒泡寻找根元素,如果不是static则从当前元素的0,0开始.如果都是static则从最外层0,0开始</p>
<p>4.fixed: 固定定位,直接相对于浏览器定位</p>
<p><strong>浏览器的展示大小叫视口</strong><br><strong>浏览器的可展示大小叫画布</strong></p>
<h3 id="脱标"><a href="#脱标" class="headerlink" title="脱标"></a>脱标</h3><p><strong>脱标元素:fixed,float,absolute</strong></p>
<p>1.可以随便设置宽高</p>
<p>2.宽高默认由内容决定</p>
<p>3.不再受标准流的约束</p>
<p>4.不再给父元素宽高数据</p>
<p>5.其实脱标是把元素转为block,而不是inline-block.但是因为是脱标不好规定父级元素,所以改为包裹内容.</p>
]]></content>
  </entry>
  <entry>
    <title>浏览器渲染页面的原理及流程</title>
    <url>/2020/06/19/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E9%A1%B5%E9%9D%A2%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="浏览器渲染页面的原理及流程"><a href="#浏览器渲染页面的原理及流程" class="headerlink" title="浏览器渲染页面的原理及流程"></a>浏览器渲染页面的原理及流程</h1><h2 id="浏览器渲染页面的流程"><a href="#浏览器渲染页面的流程" class="headerlink" title="浏览器渲染页面的流程"></a>浏览器渲染页面的流程</h2><p>1.根据html文件构建DOM树和CSSOM树。构建DOM树期间，如果遇到JS，阻塞DOM树及CSSOM树的构建，优先加载JS文件，加载完毕，再继续构建DOM树及CSSOM树。</p>
<p>2.构建渲染树（Render Tree）。构建渲染树，根据渲染树计算每个可见元素的布局，并输出到绘制流程，将像素渲染到屏幕上。</p>
<p>（渲染树（Render Tree）由DOM树、CSSOM树合并而成，但并不是必须等DOM树及CSSOM树加载完成后才开始合并构建渲染树。三者的构建并无先后条件，亦非完全独立，而是会有交叉，并行构建。因此会形成一边加载，一边解析，一边渲染的工作现象。）</p>
<p>3.页面的重绘（repaint）与重排（reflow，也有称回流）。页面渲染完成后，若JS操作了DOM节点，根据JS对DOM操作动作的大小，浏览器对页面进行重绘或是重排。</p>
<h2 id="浏览器渲染页面的原理"><a href="#浏览器渲染页面的原理" class="headerlink" title="浏览器渲染页面的原理"></a>浏览器渲染页面的原理</h2><p>1、浏览器内核拿到内容后，渲染步骤大致可以分为以下几步：</p>
<p>2、解析HTML，构建DOM树</p>
<p>3、解析CSS，生成CSS规则树</p>
<p>4、合并DOM树和CSS规则，生成render树（DOM树和CSSOM树连接在一起形成render tree .‘渲染数’）</p>
<p>5、布局render树（Layout/reflow），负责各元素尺寸、位置的计算</p>
<p>6、绘制render树（paint），绘制页面像素信息</p>
<p>7、浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上</p>
]]></content>
  </entry>
  <entry>
    <title>开课吧6.15</title>
    <url>/2020/06/19/%E5%BC%80%E8%AF%BE%E5%90%A76.15/</url>
    <content><![CDATA[<h1 id="6-15开课吧"><a href="#6-15开课吧" class="headerlink" title="6.15开课吧"></a>6.15开课吧</h1><p>1.window和document的区别</p>
<p>2.customElements.define(my-custom, myCustom)</p>
<p>3.arrt.title&amp;&amp;arrt.title.value||’默认’</p>
<p>4.** prototype属性的引入**</p>
<p>考虑到这一点，Brendan Eich决定为构造函数设置一个prototype属性。</p>
<p>这个属性包含一个对象（以下简称”prototype对象”），所有实例对象需要共享的属性和方法，都放在这个对象里面；那些不需要共享的属性和方法，就放在构造函数里面。</p>
]]></content>
  </entry>
  <entry>
    <title>数组的排序</title>
    <url>/2020/06/19/%E6%95%B0%E7%BB%84%E7%9A%84%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>###冒泡排序</p>
<p>1.第一遍 两两比较 结果:最大的跑到最后</p>
<p>2.第二遍 两两比较 结果:最后两个准确</p>
<p>代码:<br>1.第一次把最后一个值确定为最大</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i =<span class="number">0</span> ; i&lt; array.length - <span class="number">1</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(array[i]&gt; array[i+<span class="number">1</span>])&#123;</span><br><span class="line">        <span class="keyword">let</span> temp = array[i+<span class="number">1</span>];</span><br><span class="line">        array[i+<span class="number">1</span>] = array[i];</span><br><span class="line">        array[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.确定每次都是-1的两两交换的个数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> j = array.length - <span class="number">1</span> ; j &gt; <span class="number">0</span> ; j--)&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i =<span class="number">0</span> ; i&lt; j; i++)&#123;</span><br><span class="line">     <span class="keyword">if</span>(array[i]&gt; array[i+<span class="number">1</span>])&#123;</span><br><span class="line">         <span class="keyword">let</span> temp = array[i+<span class="number">1</span>];</span><br><span class="line">         array[i+<span class="number">1</span>] = array[i];</span><br><span class="line">         array[i] = temp;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>###选择排序</p>
<p>###插入排序</p>
]]></content>
  </entry>
  <entry>
    <title>盒子模型</title>
    <url>/2020/06/18/%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h1><h2 id="内容盒子"><a href="#内容盒子" class="headerlink" title="内容盒子"></a>内容盒子</h2><p>box-sizing = 内容+margin+padding</p>
<h2 id="边框盒子"><a href="#边框盒子" class="headerlink" title="边框盒子"></a>边框盒子</h2><p>box-sizing 不变,会改变content的高度.</p>
]]></content>
  </entry>
  <entry>
    <title>随笔</title>
    <url>/2020/06/19/%E9%9A%8F%E7%AC%94/</url>
    <content><![CDATA[<p>1.0,””,undefined,null,NaN只有这5个转换boolean是false</p>
<p>2.switch 是用全等(===)做判断</p>
<p>3.如果函数return 则后面都不执行<br>如果不写return 是返回undefined<br>如果写return 不写值,也是undefined</p>
<p>4.引用类型在栈空间里存的是引用堆空间的地址</p>
<p>5.shadow的参数(从左到右横向坐标,从上到下横向坐标,模糊程度,向外扩展距离,颜色)</p>
<a id="more"></a>

<ol start="6">
<li>判断对象有数据 this.purchaseType &amp;&amp; purchaseType.length &gt;0</li>
</ol>
<p>7.组件里最好不要有业务逻辑</p>
<p>8.TypeScript是JavaScript的超集，Typescript是面向对象的编程语言，js是解释性脚本语言</p>
<p>9.生命周期从applicstart开始在global.asax.cs</p>
<p>10.</p>
]]></content>
  </entry>
  <entry>
    <title>网页</title>
    <url>/2020/06/19/%E7%BD%91%E9%A1%B5/</url>
    <content><![CDATA[<p>###网页的显示过程</p>
<p>1.通过服务器返回html+js+css&gt;浏览器解析</p>
<p>2.发送至少一个请求</p>
<p>3.网页的组成：<br>  html：网页的结构<br>  css: 网页的视觉体验<br>  javascript：网页的交互</p>
<p>4.浏览器的内核：解析html+css+js<br>  （渲染内核+js引擎）<br>  trident（三叉戟）：ie、uc、360<br>  gecko（壁虎）：firefox<br>  webkit：safari、移动端浏览器控件（webview控件实际上是webkit内核）<br>  webkit-&gt;blink：google chorme</p>
<p>5.为啥有html和htm：因为早期dos只支持3个字符</p>
<p>6.HTML全称：hyper text markup language</p>
<p>7.元素（element）：标签（img）加内容</p>
<p>8.css画三角形，参考triangle.html 利用border，border的长度都是和div元素做比较</p>
<p>9.html元素<br>  1.doctype是表示html5的方式<br>  2.html分为head和body 属性为lang<br>  3.head里属性有title,meta,link(引用css和icon)</p>
]]></content>
  </entry>
  <entry>
    <title>防抖和节流</title>
    <url>/2020/06/19/%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/</url>
    <content><![CDATA[<h1 id="什么是防抖和节流？有什么区别？如何实现"><a href="#什么是防抖和节流？有什么区别？如何实现" class="headerlink" title="什么是防抖和节流？有什么区别？如何实现?"></a>什么是防抖和节流？有什么区别？如何实现?</h1><h2 id="1、防抖-debounce-触发高频事件后-n-秒内函数只会执行一次，如果-n-秒内高频事件再次被触发，则重新计算时间-把上次的timeout-clear了"><a href="#1、防抖-debounce-触发高频事件后-n-秒内函数只会执行一次，如果-n-秒内高频事件再次被触发，则重新计算时间-把上次的timeout-clear了" class="headerlink" title="1、防抖(debounce):触发高频事件后 n 秒内函数只会执行一次，如果 n 秒内高频事件再次被触发，则重新计算时间(把上次的timeout clear了)"></a>1、防抖(debounce):触发高频事件后 n 秒内函数只会执行一次，如果 n 秒内高频事件再次被触发，则重新计算时间(把上次的timeout clear了)</h2><p>_<br>举例：就好像在百度搜索时，每次输入之后都有联想词弹出，这个控制联想词的方法就不可能是输入框内容一改变就触发的，他一定是当你结束输入一段时间之后才会触发。<br>_</p>
<h2 id="2、节流-thorttle-：高频事件触发，但在-n-秒内只会执行一次，所以节流会稀释函数的执行频率"><a href="#2、节流-thorttle-：高频事件触发，但在-n-秒内只会执行一次，所以节流会稀释函数的执行频率" class="headerlink" title="2、节流(thorttle)：高频事件触发，但在 n 秒内只会执行一次，所以节流会稀释函数的执行频率"></a>2、节流(thorttle)：高频事件触发，但在 n 秒内只会执行一次，所以节流会稀释函数的执行频率</h2><p>举例：预定一个函数只有在大于等于执行周期时才执行，周期内调用不执行。就好像你在淘宝抢购某一件限量热卖商品时，你不断点刷新点购买，可是总有一段时间你点上是没有效果，这里就用到了节流，就是怕点的太快导致系统出现bug。</p>
<h2 id="3、区别：防抖动是将多次执行变为最后一次执行，节流是将多次执行变成每隔一段时间执行（防抖是最后一次把前面的timeclear，节流是如果在500ms内直接return）"><a href="#3、区别：防抖动是将多次执行变为最后一次执行，节流是将多次执行变成每隔一段时间执行（防抖是最后一次把前面的timeclear，节流是如果在500ms内直接return）" class="headerlink" title="3、区别：防抖动是将多次执行变为最后一次执行，节流是将多次执行变成每隔一段时间执行（防抖是最后一次把前面的timeclear，节流是如果在500ms内直接return）"></a>3、区别：防抖动是将多次执行变为最后一次执行，节流是将多次执行变成每隔一段时间执行（防抖是最后一次把前面的timeclear，节流是如果在500ms内直接return）</h2>]]></content>
  </entry>
</search>
